{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"README.html","text":"Overview Welcome to the Stretch RE1 User Documentation Documentation Quick Start Guide Hardware Robot Safety Guide Robot Care Guide Hardware User Guide Software Stretch Body Guide Stretch ROS Guide Stretch Firmware Guide Release Notes Version 0.0.1 (2020/05/4) Initial public release for Guthrie robot License All Hello Robot Stretch Body materials are released under the x license, as found in the LICENSE file.","title":"Home"},{"location":"README.html#overview","text":"Welcome to the Stretch RE1 User Documentation","title":"Overview"},{"location":"README.html#documentation","text":"Quick Start Guide","title":"Documentation"},{"location":"README.html#hardware","text":"Robot Safety Guide Robot Care Guide Hardware User Guide","title":"Hardware"},{"location":"README.html#software","text":"Stretch Body Guide Stretch ROS Guide Stretch Firmware Guide","title":"Software"},{"location":"README.html#release-notes","text":"Version 0.0.1 (2020/05/4) Initial public release for Guthrie robot","title":"Release Notes"},{"location":"README.html#license","text":"All Hello Robot Stretch Body materials are released under the x license, as found in the LICENSE file.","title":"License"},{"location":"hardware_user_guide.html","text":"Hardware User Guide In this guide you will gain a familiarity with the low level hardware of Stretch. USB Devices The robot hardware is almost entirely USB based. From a shell on your Stretch, check the available USB devices: lsusb ... System Check It is useful to periodically check that all robot hardware is present and operating correctly. From the console, run: robot_system_check.py When everything is present and within normal operating conditions you should see an output similar to: X Hardware Architecture The organization of the primary hardware devices are shown below. Blue indicates a USB connection. The Stretch_Body package deals primarily with the robot actuators and interfaces to the robot's custom firmware. As shown below, the USB devices on the right-hand-side are handled through the Stretch_Body API. The other devices are handles through either ROS or Ubuntu. Actuators There are two types of actuators in the robot: A Nema-23 stepper actuator that includes current feedback and a hall-effect based encoder A Dynamixel X-Series servo that includes current feedback and a hall-effect based encoder [Image dynamixel] [Image Mechaduino] The actuators include in most cases include a custom transmission on the output side of the closed loop servo controller. These transmission are of a low gear ratio (on the order of 4:1), allowing for excellent force sensitivity based on the actuator current feedback. Steppers First, take a minute to review the Stepper Class . This class directly interacts with the stepper motor and allows placing the actuator in a variety of control modes. Generally you would not use this class directly in your code, but instead would use the Arm Class , for example, when controlling the arm. The Arm Class incoporates joint limits, calibrates to joint units, and manages contact forces, etc. The Stepper Class, in contrast, provides raw access to the Stepper motor controller. Check the available stepper devices ls /dev/hello-motor* ... Let's directly jog the arm stepper. stretch_arm_jog.py Hit enter a few times and view the actuator state. Notice the position reported at the Arm level is in meters, while the position reported at the Stepper level is in radians. Also notice that the arm force being exterted, in Newtons, which is estimated based on the level of motor current. x Now jog the arm using the keyboard 'i' and 'o' comands to extend and retract. Experiment with setting the joint speeds. Take a look at the code for stretch_arm_jog.py . You can see that it is passing in velocity settings from the YAML. Looking at the YAML for the arm you can see the motion parameters, as well as other parameters that handle the calibration for the joint. arm: chain_pitch: 0.0167 chain_sprocket_teeth: 10 contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] force_adj_Newtons: 1.35 gr_spur: 3.875 i_feedforward: 0 motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} range_m: [0.0, 0.52] You can also use base_jog.py and lift_jog.py to move the other joints directly. Use care to avoid self collisions and collisions with the world when using these tools. Sensors Pimu Board Wacc Board","title":"User Guide"},{"location":"hardware_user_guide.html#hardware-user-guide","text":"In this guide you will gain a familiarity with the low level hardware of Stretch.","title":"Hardware User Guide"},{"location":"hardware_user_guide.html#usb-devices","text":"The robot hardware is almost entirely USB based. From a shell on your Stretch, check the available USB devices: lsusb ...","title":"USB Devices"},{"location":"hardware_user_guide.html#system-check","text":"It is useful to periodically check that all robot hardware is present and operating correctly. From the console, run: robot_system_check.py When everything is present and within normal operating conditions you should see an output similar to: X","title":"System Check"},{"location":"hardware_user_guide.html#hardware-architecture","text":"The organization of the primary hardware devices are shown below. Blue indicates a USB connection. The Stretch_Body package deals primarily with the robot actuators and interfaces to the robot's custom firmware. As shown below, the USB devices on the right-hand-side are handled through the Stretch_Body API. The other devices are handles through either ROS or Ubuntu.","title":"Hardware Architecture"},{"location":"hardware_user_guide.html#actuators","text":"There are two types of actuators in the robot: A Nema-23 stepper actuator that includes current feedback and a hall-effect based encoder A Dynamixel X-Series servo that includes current feedback and a hall-effect based encoder [Image dynamixel] [Image Mechaduino] The actuators include in most cases include a custom transmission on the output side of the closed loop servo controller. These transmission are of a low gear ratio (on the order of 4:1), allowing for excellent force sensitivity based on the actuator current feedback.","title":"Actuators"},{"location":"hardware_user_guide.html#steppers","text":"First, take a minute to review the Stepper Class . This class directly interacts with the stepper motor and allows placing the actuator in a variety of control modes. Generally you would not use this class directly in your code, but instead would use the Arm Class , for example, when controlling the arm. The Arm Class incoporates joint limits, calibrates to joint units, and manages contact forces, etc. The Stepper Class, in contrast, provides raw access to the Stepper motor controller. Check the available stepper devices ls /dev/hello-motor* ... Let's directly jog the arm stepper. stretch_arm_jog.py Hit enter a few times and view the actuator state. Notice the position reported at the Arm level is in meters, while the position reported at the Stepper level is in radians. Also notice that the arm force being exterted, in Newtons, which is estimated based on the level of motor current. x Now jog the arm using the keyboard 'i' and 'o' comands to extend and retract. Experiment with setting the joint speeds. Take a look at the code for stretch_arm_jog.py . You can see that it is passing in velocity settings from the YAML. Looking at the YAML for the arm you can see the motion parameters, as well as other parameters that handle the calibration for the joint. arm: chain_pitch: 0.0167 chain_sprocket_teeth: 10 contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] force_adj_Newtons: 1.35 gr_spur: 3.875 i_feedforward: 0 motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} range_m: [0.0, 0.52] You can also use base_jog.py and lift_jog.py to move the other joints directly. Use care to avoid self collisions and collisions with the world when using these tools.","title":"Steppers"},{"location":"hardware_user_guide.html#sensors","text":"","title":"Sensors"},{"location":"hardware_user_guide.html#pimu-board","text":"","title":"Pimu Board"},{"location":"hardware_user_guide.html#wacc-board","text":"","title":"Wacc Board"},{"location":"quick_start_guide.html","text":"Stretch RE1: Quick Start Guide Welcome to your Stretch RE1! This guide will get you started with your new robot. We'd welcome your feedback as you get to know your robot. Please let us know of any issues, questions, or points of confusion. Just email us at support@hello-robot.com. To start, we highly recommend you first go through the Robot Safety Guide and watch our Robot Safety Video (link). Unboxing Please watch our unboxing video (Coming soon) Robot Tour A few items you'll want to know about before getting started. Power The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. We recommend keeping the charger plugged in whenever it isn't running untethered. Runstop The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume. Safe Handling Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Backdriving the head and wrist. They will backdrive but they want to go at their own speed. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense) Hello World Demo Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step... Get Plugged In Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Log in to the robot computer. The default user credentials came in the box with the robot. Before you can start coding you'll want to first kill off the XBox controller process which runs by default at boot: >> pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop' Start Coding Open up a Terminal. From the command line, first verify that that all of the hardware is present and happy >> stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot >> stretch_robot_home.py Once the robot has homed, let's write some quick test code: >>ipython Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.stow() robot.arm.move_to(0.25) robot.push_command() robot.arm.move_to(0.0) robot.push_command() robot.lift.move_to(0.4) robot.push_command() robot.pretty_print() robot.lift.pretty_print() robot.head.pose('tool') robot.head.pose('ahead') robot.end_of_arm.move_to('wrist_yaw',0) robot.end_of_arm.move_to('stretch_gripper',50) robot.end_of_arm.move_to('gripper',-50) robot.stow() robot.stop() URDF Visualization Finally, let's look at the factory calibrated URDF for your robot. From the console run: >> stretch_urdf_show.py --motion That's it, happy coding!","title":"Quick Start"},{"location":"quick_start_guide.html#stretch-re1-quick-start-guide","text":"Welcome to your Stretch RE1! This guide will get you started with your new robot. We'd welcome your feedback as you get to know your robot. Please let us know of any issues, questions, or points of confusion. Just email us at support@hello-robot.com. To start, we highly recommend you first go through the Robot Safety Guide and watch our Robot Safety Video (link).","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide.html#unboxing","text":"Please watch our unboxing video (Coming soon)","title":"Unboxing"},{"location":"quick_start_guide.html#robot-tour","text":"A few items you'll want to know about before getting started.","title":"Robot Tour"},{"location":"quick_start_guide.html#power","text":"The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. We recommend keeping the charger plugged in whenever it isn't running untethered.","title":"Power"},{"location":"quick_start_guide.html#runstop","text":"The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume.","title":"Runstop"},{"location":"quick_start_guide.html#safe-handling","text":"Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Backdriving the head and wrist. They will backdrive but they want to go at their own speed. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense)","title":"Safe Handling"},{"location":"quick_start_guide.html#hello-world-demo","text":"Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step...","title":"Hello World Demo"},{"location":"quick_start_guide.html#get-plugged-in","text":"Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Log in to the robot computer. The default user credentials came in the box with the robot. Before you can start coding you'll want to first kill off the XBox controller process which runs by default at boot: >> pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop'","title":"Get Plugged In"},{"location":"quick_start_guide.html#start-coding","text":"Open up a Terminal. From the command line, first verify that that all of the hardware is present and happy >> stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot >> stretch_robot_home.py Once the robot has homed, let's write some quick test code: >>ipython Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.stow() robot.arm.move_to(0.25) robot.push_command() robot.arm.move_to(0.0) robot.push_command() robot.lift.move_to(0.4) robot.push_command() robot.pretty_print() robot.lift.pretty_print() robot.head.pose('tool') robot.head.pose('ahead') robot.end_of_arm.move_to('wrist_yaw',0) robot.end_of_arm.move_to('stretch_gripper',50) robot.end_of_arm.move_to('gripper',-50) robot.stow() robot.stop()","title":"Start Coding"},{"location":"quick_start_guide.html#urdf-visualization","text":"Finally, let's look at the factory calibrated URDF for your robot. From the console run: >> stretch_urdf_show.py --motion That's it, happy coding!","title":"URDF Visualization"},{"location":"robot_care_guide.html","text":"Robot Care Guide In this tutorial you will gain a familiarity with the low level hardware of Stretch. See the for additional details on the hardware use. USB Devices The robot hardware is almost entirely USB based. From a shell on your Stretch, check the available USB devices: lsusb ... System Check It is useful to periodically check that all robot hardware is present and operating correctly. From the console, run: robot_system_check.py When everything is present and within normal operating conditions you should see an output similar to: X Hardware Architecture The organization of the primary hardware devices are shown below. Blue indicates a USB connection. The Stretch_Body package deals primarily with the robot actuators and interfaces to the robot's custom firmware. As shown below, the USB devices on the right-hand-side are handled through the Stretch_Body API. The other devices are handles through either ROS or Ubuntu. Actuators There are two types of actuators in the robot: A Nema-23 stepper actuator that includes current feedback and a hall-effect based encoder A Dynamixel X-Series servo that includes current feedback and a hall-effect based encoder [Image dynamixel] [Image Mechaduino] The actuators include in most cases include a custom transmission on the output side of the closed loop servo controller. These transmission are of a low gear ratio (on the order of 4:1), allowing for excellent force sensitivity based on the actuator current feedback. Steppers First, take a minute to review the Stepper Class . This class directly interacts with the stepper motor and allows placing the actuator in a variety of control modes. Generally you would not use this class directly in your code, but instead would use the Arm Class , for example, when controlling the arm. The Arm Class incoporates joint limits, calibrates to joint units, and manages contact forces, etc. The Stepper Class, in contrast, provides raw access to the Stepper motor controller. Check the available stepper devices ls /dev/hello-motor* ... Let's directly jog the arm stepper. stretch_arm_jog.py Hit enter a few times and view the actuator state. Notice the position reported at the Arm level is in meters, while the position reported at the Stepper level is in radians. Also notice that the arm force being exterted, in Newtons, which is estimated based on the level of motor current. x Now jog the arm using the keyboard 'i' and 'o' comands to extend and retract. Experiment with setting the joint speeds. Take a look at the code for stretch_arm_jog.py . You can see that it is passing in velocity settings from the YAML. Looking at the YAML for the arm you can see the motion parameters, as well as other parameters that handle the calibration for the joint. arm: chain_pitch: 0.0167 chain_sprocket_teeth: 10 contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] force_adj_Newtons: 1.35 gr_spur: 3.875 i_feedforward: 0 motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} range_m: [0.0, 0.52] You can also use base_jog.py and lift_jog.py to move the other joints directly. Use care to avoid self collisions and collisions with the world when using these tools. Sensors Pimu Board Wacc Board","title":"Robot Care"},{"location":"robot_care_guide.html#robot-care-guide","text":"In this tutorial you will gain a familiarity with the low level hardware of Stretch. See the for additional details on the hardware use.","title":"Robot Care Guide"},{"location":"robot_care_guide.html#usb-devices","text":"The robot hardware is almost entirely USB based. From a shell on your Stretch, check the available USB devices: lsusb ...","title":"USB Devices"},{"location":"robot_care_guide.html#system-check","text":"It is useful to periodically check that all robot hardware is present and operating correctly. From the console, run: robot_system_check.py When everything is present and within normal operating conditions you should see an output similar to: X","title":"System Check"},{"location":"robot_care_guide.html#hardware-architecture","text":"The organization of the primary hardware devices are shown below. Blue indicates a USB connection. The Stretch_Body package deals primarily with the robot actuators and interfaces to the robot's custom firmware. As shown below, the USB devices on the right-hand-side are handled through the Stretch_Body API. The other devices are handles through either ROS or Ubuntu.","title":"Hardware Architecture"},{"location":"robot_care_guide.html#actuators","text":"There are two types of actuators in the robot: A Nema-23 stepper actuator that includes current feedback and a hall-effect based encoder A Dynamixel X-Series servo that includes current feedback and a hall-effect based encoder [Image dynamixel] [Image Mechaduino] The actuators include in most cases include a custom transmission on the output side of the closed loop servo controller. These transmission are of a low gear ratio (on the order of 4:1), allowing for excellent force sensitivity based on the actuator current feedback.","title":"Actuators"},{"location":"robot_care_guide.html#steppers","text":"First, take a minute to review the Stepper Class . This class directly interacts with the stepper motor and allows placing the actuator in a variety of control modes. Generally you would not use this class directly in your code, but instead would use the Arm Class , for example, when controlling the arm. The Arm Class incoporates joint limits, calibrates to joint units, and manages contact forces, etc. The Stepper Class, in contrast, provides raw access to the Stepper motor controller. Check the available stepper devices ls /dev/hello-motor* ... Let's directly jog the arm stepper. stretch_arm_jog.py Hit enter a few times and view the actuator state. Notice the position reported at the Arm level is in meters, while the position reported at the Stepper level is in radians. Also notice that the arm force being exterted, in Newtons, which is estimated based on the level of motor current. x Now jog the arm using the keyboard 'i' and 'o' comands to extend and retract. Experiment with setting the joint speeds. Take a look at the code for stretch_arm_jog.py . You can see that it is passing in velocity settings from the YAML. Looking at the YAML for the arm you can see the motion parameters, as well as other parameters that handle the calibration for the joint. arm: chain_pitch: 0.0167 chain_sprocket_teeth: 10 contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] force_adj_Newtons: 1.35 gr_spur: 3.875 i_feedforward: 0 motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} range_m: [0.0, 0.52] You can also use base_jog.py and lift_jog.py to move the other joints directly. Use care to avoid self collisions and collisions with the world when using these tools.","title":"Steppers"},{"location":"robot_care_guide.html#sensors","text":"","title":"Sensors"},{"location":"robot_care_guide.html#pimu-board","text":"","title":"Pimu Board"},{"location":"robot_care_guide.html#wacc-board","text":"","title":"Wacc Board"},{"location":"robot_safety_guide.html","text":"Robot Safety Guide Before You Start This manual is intended to help users become familiar with safe operating practices and use of the Hello Robot Stretch RE1 All users should read and become familiar with the safe operating procedures before operating the robot. Disclaimer The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section Regulatory Compliance for further details. Safety It is important for users to keep safety in mind at all times while operating a Hello Robot. When improperly used it is possible for users, bystanders, and property to become harmed. All new users of Hello Robot products should be trained by experienced personnel on best practices for safe operation and interaction with the robot. Because Stretch is a mobile manipulator with autonomous capabilities, it may move in unpredictable ways. It may carry potentially dangerous objects that can contact people in unexpected ways. While it is relatively lightweight and able to only exert moderate forces on the environment, dangerous conditions can still occur. The moving components of the robot pose dangers of pinching and crushing of body parts. People should always be aware and attentive to the motion and of Stretch robots. The intended use of the Stretch RE1 is for research and development of mobile manipulation applications within laboratory settings. No robot is ever inherently safe and common sense safety measures should be applied when using Stretch, Safety Features We have considered safety from the outset in the design of Stretch. Lightweight design: The overall mass of Stretch is 22Kg, and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : The arrangement of Stretch\u2019s manipulator means that it doesn\u2019t have to counteract gravity on a larger lever arm. As a result, the motors and gearboxes are much lower torque and lower weight than a traditional robot manipulator, allowing us to avoid the often dangerous strong shoulder joints of robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low, gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and, arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Velocity limits : Fast motions of the base are restricted when the arm is up high and tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. An over-tilt condition will trigger a runstop event, causing motion to stop. Use Common Sense The most important aspect of safety with Stretch is to use common sense, including Do not operate unattended by an experienced operator Exhibit caution when operating around young children who may interact with it in unexpected ways Keep an eye on cords, rugs, and any other floor hazards as it drives Keep it at least 5 meters from ledges, curbs, stairs, and any other toppling hazard Keep long hair and clothes away from the moving components of the robot. Do not operate out doors Keep the robot dry and do not operate around liquids Do not attempt to ride the robot If the robot appears to be damaged, stop operation immediately Do not have the robot hold any sharp objects. Use two people to lift and carry the robot when needed Safety Markings Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast: Top of base, indicating potential pinch point between arm and base. Runstop The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid The default behavior of the Safety Mode for each actuator is: Actuator Safety Mode Behavior Notes Left wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Right wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Lift Float Motor drive is powered on and commanding current to motor that compensates for gravity (eg, float). Lift can be backdriven by the user. Arm Float Motor drive is powered off. Arm can be backdriven manually by user. Safety Hazards Like all robots, Stretch has some areas that require extra attention for safe operation. Sharp Edges Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp corners edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted. Toppling Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and it hits a bump, threshold, or other change in floor property If the arm is raised up high and it pushes or pulls on the environment with sufficient force. It drives over a drop-off such as a stair or curb NOTE: While the Stretch RE1 has cliff sensors, they do not currently inhibit motion of the base. As such, it is possible for the robot to fall down stairs and hurt itself or a person. Pinch Points Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. C Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers. Crush Points The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. Nominally, this threshold is around 70N but it can be configured in software. When enabled an operating as expected, the Guarded Move controller should keep contact forces within comfortable and safe levels. The diagrams below show the potential crush points at the top and bottom of the lift range of motion.","title":"Robot Safety"},{"location":"robot_safety_guide.html#robot-safety-guide","text":"","title":"Robot Safety Guide"},{"location":"robot_safety_guide.html#before-you-start","text":"This manual is intended to help users become familiar with safe operating practices and use of the Hello Robot Stretch RE1 All users should read and become familiar with the safe operating procedures before operating the robot.","title":"Before You Start"},{"location":"robot_safety_guide.html#disclaimer","text":"The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section Regulatory Compliance for further details.","title":"Disclaimer"},{"location":"robot_safety_guide.html#safety","text":"It is important for users to keep safety in mind at all times while operating a Hello Robot. When improperly used it is possible for users, bystanders, and property to become harmed. All new users of Hello Robot products should be trained by experienced personnel on best practices for safe operation and interaction with the robot. Because Stretch is a mobile manipulator with autonomous capabilities, it may move in unpredictable ways. It may carry potentially dangerous objects that can contact people in unexpected ways. While it is relatively lightweight and able to only exert moderate forces on the environment, dangerous conditions can still occur. The moving components of the robot pose dangers of pinching and crushing of body parts. People should always be aware and attentive to the motion and of Stretch robots. The intended use of the Stretch RE1 is for research and development of mobile manipulation applications within laboratory settings. No robot is ever inherently safe and common sense safety measures should be applied when using Stretch,","title":"Safety"},{"location":"robot_safety_guide.html#safety-features","text":"We have considered safety from the outset in the design of Stretch. Lightweight design: The overall mass of Stretch is 22Kg, and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : The arrangement of Stretch\u2019s manipulator means that it doesn\u2019t have to counteract gravity on a larger lever arm. As a result, the motors and gearboxes are much lower torque and lower weight than a traditional robot manipulator, allowing us to avoid the often dangerous strong shoulder joints of robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low, gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and, arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Velocity limits : Fast motions of the base are restricted when the arm is up high and tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. An over-tilt condition will trigger a runstop event, causing motion to stop.","title":"Safety Features"},{"location":"robot_safety_guide.html#use-common-sense","text":"The most important aspect of safety with Stretch is to use common sense, including Do not operate unattended by an experienced operator Exhibit caution when operating around young children who may interact with it in unexpected ways Keep an eye on cords, rugs, and any other floor hazards as it drives Keep it at least 5 meters from ledges, curbs, stairs, and any other toppling hazard Keep long hair and clothes away from the moving components of the robot. Do not operate out doors Keep the robot dry and do not operate around liquids Do not attempt to ride the robot If the robot appears to be damaged, stop operation immediately Do not have the robot hold any sharp objects. Use two people to lift and carry the robot when needed","title":"Use Common Sense"},{"location":"robot_safety_guide.html#safety-markings","text":"Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast: Top of base, indicating potential pinch point between arm and base.","title":"Safety Markings"},{"location":"robot_safety_guide.html#runstop","text":"The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid The default behavior of the Safety Mode for each actuator is: Actuator Safety Mode Behavior Notes Left wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Right wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Lift Float Motor drive is powered on and commanding current to motor that compensates for gravity (eg, float). Lift can be backdriven by the user. Arm Float Motor drive is powered off. Arm can be backdriven manually by user.","title":"Runstop"},{"location":"robot_safety_guide.html#safety-hazards","text":"Like all robots, Stretch has some areas that require extra attention for safe operation.","title":"Safety Hazards"},{"location":"robot_safety_guide.html#sharp-edges","text":"Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp corners edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted.","title":"Sharp Edges"},{"location":"robot_safety_guide.html#toppling","text":"Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and it hits a bump, threshold, or other change in floor property If the arm is raised up high and it pushes or pulls on the environment with sufficient force. It drives over a drop-off such as a stair or curb NOTE: While the Stretch RE1 has cliff sensors, they do not currently inhibit motion of the base. As such, it is possible for the robot to fall down stairs and hurt itself or a person.","title":"Toppling"},{"location":"robot_safety_guide.html#pinch-points","text":"Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. C Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers.","title":"Pinch Points"},{"location":"robot_safety_guide.html#crush-points","text":"The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. Nominally, this threshold is around 70N but it can be configured in software. When enabled an operating as expected, the Guarded Move controller should keep contact forces within comfortable and safe levels. The diagrams below show the potential crush points at the top and bottom of the lift range of motion.","title":"Crush Points"},{"location":"stretch_body_guide.html","text":"Stretch Body Guide The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The primary interface is the Robot class . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators. Robot Interface This quick start guide provides a high level introduction to the Robot API and how to program the Stretch robot using its low level Python interface. The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() for i in range(10): robot.pretty_print() time.sleep(0.25) robot.stop() Looking at this in detail: import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. robot=stretch_body.robot.Robot() robot.startup() Here we instantiate an instance of our Robot. The call to startup( ) opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. for i in range(10): robot.pretty_print() time.sleep(0.25) The call to pretty_print( ) prints to console all of the robot's sensor and state data. robot.stop() Finally, the stop( ) method shuts down the Robot threads and cleanly closes the open serial ports. Units The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians The Robot Status The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm(Device): def __init__(self): ... self.status = {'pos': 0.0, 'vel': 0.0, 'force':0.0, \\ 'motor':self.motor.status,'timestamp_pc':0} The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot.arm.status['pos']>0.25: print 'Arm extension greater than 0.25m' If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status=robot.get_status() if status['arm']['pos']>0.25: print 'Arm extension greater than 0.25m' The Robot Command In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.arm.move_by(-0.1) robot.push_command() time.sleep(2.0) robot.stop() A few important things are going on: robot.arm.move_by(0.1) The move_by( ) method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. robot.push_command() The push_command( ) causes all queued up RPC commands to be executed at once. In this example we call sleep( ) to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot.arm.move_by(0.1) robot.lift.move_by(0.1) robot.base.translate_by(0.1) robot.push_command() Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section. Stowing and Homing After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot.is_calibrated(): robot.home() #blocking Or it can be done manually after boot using the command line tool: >>$ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot.stow() #blocking Or it can be done manually from the command line when needed: >>$ stretch_robot_stow.py Scripting the Robot A simplified design pattern to script the Robot is as follows #!/usr/bin/env python import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot=stretch_body.robot.Robot() robot.startup() x_move_base =0 x_move_arm =0 x_move_lift =0 x_move_head_pan =0 x_move_head_tilt =0 x_move_wrist_yaw =0 x_move_gripper =0 def update_my_behavior(status): #Update the joint commands based on the status data pass try: while True: #Get a snapshot of the robot status data status=robot.get_status() #Compute new position targets based on sensor data update_my_behavior(status) #Queue new targets to devices robot.base.translate_by(x_move_base) #or robot.base.rotate_by() robot.arm.move_by(x_move_arm) robot.lift.move_by(x_move_lift) robot.head.move_by('head_pan',x_move_head_pan) robot.head.move_by('head_tilt',x_move_head_tilt) robot.end_of_arm.move_by('wrist_yaw',x_move_wrist_yaw) robot.end_of_arm.move_by('gripper',x_move_gripper) #Synchronized send of new position targets robot.push_command() #Wait for next control cycle time.sleep(0.1) except (KeyboardInterrupt, SystemExit,ThreadServiceExit) pass robot.stop() Command Line Tools The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. >>$ stretch_ stretch_arm_home.py stretch_head_jog.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_lift_home.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wrist_yaw_jog.py stretch_base_jog.py stretch_lift_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_xbox_controller_teleop.py stretch_gripper_home.py stretch_pimu_jog.py stretch_robot_jog.py stretch_wacc_jog.py stretch_gripper_jog.py stretch_pimu_scope.py stretch_robot_keyboard_teleop.py stretch_wacc_scope.py stretch_urdf_show.py stretch_rp_lidar_jog.py stretch_hardware_echo.py All tools accept '--help' as a command line argument to learn its function. For example: >>$ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap Commonly Used Tools These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem. Robot Motion Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.stop() Motion Profiles All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm: motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} To move the arm quickly instead: vel_fast_m = robot.arm.params['motion']['fast']['vel_m'] accel_fast_m = robot.arm.params['motion']['fast']['accel_m'] robot.arm.move_by(x_m=0.1,v_m=vel_fast_m, a_m=accel_fast_m) robot.push_command() The motion will fall back to the 'default' settings found in the YAML if no parameters are provided. Range of Motion All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift: range_m: [0.1, 1.095] Control Modes Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the device.startup( ) function is called it transitions to its Control Mode. It is placed back in Safety Mode when device.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot.base.translate_by(x_m=0.5) robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.1) #switch to velocity controller robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.0) #stop motion robot.push_command() As shown, care should be taken to reduce commanded velocities to zero to avoid runaway. Runstop Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot.pimu.status['runstop_event']: robot.pimu.runstop_event_reset() robot.push_command() Guarded Motion The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm: contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot.arm.move_by(x_m=0.1, contact_thresh_pos_N=30.0) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot.arm.motor.status['in_guarded_event']: print 'Arm has made contact' The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot.arm.move_to(0.5) #Reach all the way out robot.push_command() while robot.arm.status['pos']<0.5: if robot.arm.motor.status['in_guarded_event']: print 'Contact made at', robot.arm.status['pos'] break time.sleep(0.1) print 'Retracting...' robot.arm.move_to(0.0) robot.push_command( ) Note: The units of Newtons are approximations only and may not be accurate to real world contact forces. Synchronized Motion The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm: gains: {enable_sync_mode: 1,...} Motion Status It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot.arm.status['pos'] #Joint position robot.arm.status['vel'] #Joint velocity robot.arm.status['force'] #Joint force (derived from motor current) robot.arm.motor.status['near_pos_setpoint'] #Is sensed position near commanded position robot.arm.motor.status['near_vel_setpoint'] #Is sensed velocity near commanded velocity robot.arm.motor.status['is_moving'] #Is the joint in motion robot.arm.motor.status['in_guarded_event'] #Has a guarded event occured robot.arm.motor.status['in_safety_event'] #Has a safety event occured Update Rates The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics. Robot Parameters All robot data is stored in the stretch_user directory. The location of this directory can be found by: >>$ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) cd $HELLO_FLEET_PATH/$HELLO_FLEET_ID >>$ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users. Calibration Data The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development. YAML Data Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools. Factory Settings This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base. User Settings The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params: stretch_re1_factory_params.yaml tool_params: stretch_re1_tool_params.yaml lift: contact_thresh_N: [-60, 60] motion: default: {accel_m: 0.15, vel_m: 0.095} arm: contact_thresh_N: [-80, 80] motion: default: {accel_m: 0.14, vel_m: 0.14} base: motion: default: {accel_m: 0.1, vel_m: 0.15} End of Arm Tool Settings The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information coming soon.","title":"Stretch Body package"},{"location":"stretch_body_guide.html#stretch-body-guide","text":"The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The primary interface is the Robot class . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators.","title":"Stretch Body Guide"},{"location":"stretch_body_guide.html#robot-interface","text":"This quick start guide provides a high level introduction to the Robot API and how to program the Stretch robot using its low level Python interface. The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() for i in range(10): robot.pretty_print() time.sleep(0.25) robot.stop() Looking at this in detail: import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. robot=stretch_body.robot.Robot() robot.startup() Here we instantiate an instance of our Robot. The call to startup( ) opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. for i in range(10): robot.pretty_print() time.sleep(0.25) The call to pretty_print( ) prints to console all of the robot's sensor and state data. robot.stop() Finally, the stop( ) method shuts down the Robot threads and cleanly closes the open serial ports.","title":"Robot Interface"},{"location":"stretch_body_guide.html#units","text":"The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians","title":"Units"},{"location":"stretch_body_guide.html#the-robot-status","text":"The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm(Device): def __init__(self): ... self.status = {'pos': 0.0, 'vel': 0.0, 'force':0.0, \\ 'motor':self.motor.status,'timestamp_pc':0} The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot.arm.status['pos']>0.25: print 'Arm extension greater than 0.25m' If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status=robot.get_status() if status['arm']['pos']>0.25: print 'Arm extension greater than 0.25m'","title":"The Robot Status"},{"location":"stretch_body_guide.html#the-robot-command","text":"In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.arm.move_by(-0.1) robot.push_command() time.sleep(2.0) robot.stop() A few important things are going on: robot.arm.move_by(0.1) The move_by( ) method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. robot.push_command() The push_command( ) causes all queued up RPC commands to be executed at once. In this example we call sleep( ) to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot.arm.move_by(0.1) robot.lift.move_by(0.1) robot.base.translate_by(0.1) robot.push_command() Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section.","title":"The Robot Command"},{"location":"stretch_body_guide.html#stowing-and-homing","text":"After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot.is_calibrated(): robot.home() #blocking Or it can be done manually after boot using the command line tool: >>$ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot.stow() #blocking Or it can be done manually from the command line when needed: >>$ stretch_robot_stow.py","title":"Stowing and Homing"},{"location":"stretch_body_guide.html#scripting-the-robot","text":"A simplified design pattern to script the Robot is as follows #!/usr/bin/env python import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot=stretch_body.robot.Robot() robot.startup() x_move_base =0 x_move_arm =0 x_move_lift =0 x_move_head_pan =0 x_move_head_tilt =0 x_move_wrist_yaw =0 x_move_gripper =0 def update_my_behavior(status): #Update the joint commands based on the status data pass try: while True: #Get a snapshot of the robot status data status=robot.get_status() #Compute new position targets based on sensor data update_my_behavior(status) #Queue new targets to devices robot.base.translate_by(x_move_base) #or robot.base.rotate_by() robot.arm.move_by(x_move_arm) robot.lift.move_by(x_move_lift) robot.head.move_by('head_pan',x_move_head_pan) robot.head.move_by('head_tilt',x_move_head_tilt) robot.end_of_arm.move_by('wrist_yaw',x_move_wrist_yaw) robot.end_of_arm.move_by('gripper',x_move_gripper) #Synchronized send of new position targets robot.push_command() #Wait for next control cycle time.sleep(0.1) except (KeyboardInterrupt, SystemExit,ThreadServiceExit) pass robot.stop()","title":"Scripting the Robot"},{"location":"stretch_body_guide.html#command-line-tools","text":"The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. >>$ stretch_ stretch_arm_home.py stretch_head_jog.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_lift_home.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wrist_yaw_jog.py stretch_base_jog.py stretch_lift_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_xbox_controller_teleop.py stretch_gripper_home.py stretch_pimu_jog.py stretch_robot_jog.py stretch_wacc_jog.py stretch_gripper_jog.py stretch_pimu_scope.py stretch_robot_keyboard_teleop.py stretch_wacc_scope.py stretch_urdf_show.py stretch_rp_lidar_jog.py stretch_hardware_echo.py All tools accept '--help' as a command line argument to learn its function. For example: >>$ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap","title":"Command Line Tools"},{"location":"stretch_body_guide.html#commonly-used-tools","text":"These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem.","title":"Commonly Used Tools"},{"location":"stretch_body_guide.html#robot-motion","text":"Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.stop()","title":"Robot Motion"},{"location":"stretch_body_guide.html#motion-profiles","text":"All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm: motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} To move the arm quickly instead: vel_fast_m = robot.arm.params['motion']['fast']['vel_m'] accel_fast_m = robot.arm.params['motion']['fast']['accel_m'] robot.arm.move_by(x_m=0.1,v_m=vel_fast_m, a_m=accel_fast_m) robot.push_command() The motion will fall back to the 'default' settings found in the YAML if no parameters are provided.","title":"Motion Profiles"},{"location":"stretch_body_guide.html#range-of-motion","text":"All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift: range_m: [0.1, 1.095]","title":"Range of Motion"},{"location":"stretch_body_guide.html#control-modes","text":"Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the device.startup( ) function is called it transitions to its Control Mode. It is placed back in Safety Mode when device.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot.base.translate_by(x_m=0.5) robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.1) #switch to velocity controller robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.0) #stop motion robot.push_command() As shown, care should be taken to reduce commanded velocities to zero to avoid runaway.","title":"Control Modes"},{"location":"stretch_body_guide.html#runstop","text":"Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot.pimu.status['runstop_event']: robot.pimu.runstop_event_reset() robot.push_command()","title":"Runstop"},{"location":"stretch_body_guide.html#guarded-motion","text":"The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm: contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot.arm.move_by(x_m=0.1, contact_thresh_pos_N=30.0) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot.arm.motor.status['in_guarded_event']: print 'Arm has made contact' The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot.arm.move_to(0.5) #Reach all the way out robot.push_command() while robot.arm.status['pos']<0.5: if robot.arm.motor.status['in_guarded_event']: print 'Contact made at', robot.arm.status['pos'] break time.sleep(0.1) print 'Retracting...' robot.arm.move_to(0.0) robot.push_command( ) Note: The units of Newtons are approximations only and may not be accurate to real world contact forces.","title":"Guarded Motion"},{"location":"stretch_body_guide.html#synchronized-motion","text":"The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm: gains: {enable_sync_mode: 1,...}","title":"Synchronized Motion"},{"location":"stretch_body_guide.html#motion-status","text":"It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot.arm.status['pos'] #Joint position robot.arm.status['vel'] #Joint velocity robot.arm.status['force'] #Joint force (derived from motor current) robot.arm.motor.status['near_pos_setpoint'] #Is sensed position near commanded position robot.arm.motor.status['near_vel_setpoint'] #Is sensed velocity near commanded velocity robot.arm.motor.status['is_moving'] #Is the joint in motion robot.arm.motor.status['in_guarded_event'] #Has a guarded event occured robot.arm.motor.status['in_safety_event'] #Has a safety event occured","title":"Motion Status"},{"location":"stretch_body_guide.html#update-rates","text":"The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics.","title":"Update Rates"},{"location":"stretch_body_guide.html#robot-parameters","text":"All robot data is stored in the stretch_user directory. The location of this directory can be found by: >>$ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) cd $HELLO_FLEET_PATH/$HELLO_FLEET_ID >>$ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users.","title":"Robot Parameters"},{"location":"stretch_body_guide.html#calibration-data","text":"The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development.","title":"Calibration Data"},{"location":"stretch_body_guide.html#yaml-data","text":"Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools.","title":"YAML Data"},{"location":"stretch_body_guide.html#factory-settings","text":"This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base.","title":"Factory Settings"},{"location":"stretch_body_guide.html#user-settings","text":"The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params: stretch_re1_factory_params.yaml tool_params: stretch_re1_tool_params.yaml lift: contact_thresh_N: [-60, 60] motion: default: {accel_m: 0.15, vel_m: 0.095} arm: contact_thresh_N: [-80, 80] motion: default: {accel_m: 0.14, vel_m: 0.14} base: motion: default: {accel_m: 0.1, vel_m: 0.15}","title":"User Settings"},{"location":"stretch_body_guide.html#end-of-arm-tool-settings","text":"The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information coming soon.","title":"End of Arm Tool Settings"},{"location":"stretch_ros_guide.html","text":"Stretch ROS Guide Coming soon.","title":"Stretch ROS Guide"},{"location":"stretch_ros_guide.html#stretch-ros-guide","text":"Coming soon.","title":"Stretch ROS Guide"}]}
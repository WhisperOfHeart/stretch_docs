{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Welcome to the home for all Stretch RE1 User Documentation. Quick Start Resource Description Stretch Unboxing Video (Coming soon) How to unpack your new Stretch Stretch Best Practices Video (Coming soon) How to safely work with Stretch Stretch Quick Start Guide Getting started - Xbox Teleoperation Demo and beyond Stretch Untethered Operation Guide to working with Stretch untethered Hardware Resource Description Stretch Hardware User Guide Specification and functional description of the Stretch RE1 Hardware Stretch Tool Share Open resource to share designs and code for end-of-arm tools Stretch Safety Guide Guide for safe use of the Stretch RE1 Stretch Care Guide Guide to maintain a healthy Stretch Software Body Interface Resource Description Stretch Body Guide Guide to the low level Python interface to the Stretch hardware Stretch Body API Reference API Reference to stretch_body python library Stretch Firmware Guide Guide to updating the Stretch Firmware Stretch Installation Guide Guide to installing a new user and managing the Stretch installation Stretch Factory Tools Guide to factory tools for hardware calibration and introspection Stretch Wrist Expansion Header (Coming soon) Tutorial to the Arduino expansion header in the wrist ROS Interface Resource Description Stretch Autonomy Demos Demonstration of simple autonomous manipulations Stretch Deep Perception Demos Demonstration of using open deep learning models to perceive the world Stretch FUNMAP Demo Demonstration of Fast Unified Navigation, Manipulation And Planning (FUNMAP) Stretch URDF Calibration Tutorial Tutorial on URDF (re)calibration Stretch Description Guide Guide to working with the Stretch URDF and using 3rd party tools. Release Notes Batch Errata License This documentation is only to be used for an authentic Stretch RE1 robot produced and sold by Hello Robot Inc. All Hello Robot stretch_docs related materials are released under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license. . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Home"},{"location":"#overview","text":"Welcome to the home for all Stretch RE1 User Documentation.","title":"Overview"},{"location":"#quick-start","text":"Resource Description Stretch Unboxing Video (Coming soon) How to unpack your new Stretch Stretch Best Practices Video (Coming soon) How to safely work with Stretch Stretch Quick Start Guide Getting started - Xbox Teleoperation Demo and beyond Stretch Untethered Operation Guide to working with Stretch untethered","title":"Quick Start"},{"location":"#hardware","text":"Resource Description Stretch Hardware User Guide Specification and functional description of the Stretch RE1 Hardware Stretch Tool Share Open resource to share designs and code for end-of-arm tools Stretch Safety Guide Guide for safe use of the Stretch RE1 Stretch Care Guide Guide to maintain a healthy Stretch","title":"Hardware"},{"location":"#software","text":"","title":"Software"},{"location":"#body-interface","text":"Resource Description Stretch Body Guide Guide to the low level Python interface to the Stretch hardware Stretch Body API Reference API Reference to stretch_body python library Stretch Firmware Guide Guide to updating the Stretch Firmware Stretch Installation Guide Guide to installing a new user and managing the Stretch installation Stretch Factory Tools Guide to factory tools for hardware calibration and introspection Stretch Wrist Expansion Header (Coming soon) Tutorial to the Arduino expansion header in the wrist","title":"Body Interface"},{"location":"#ros-interface","text":"Resource Description Stretch Autonomy Demos Demonstration of simple autonomous manipulations Stretch Deep Perception Demos Demonstration of using open deep learning models to perceive the world Stretch FUNMAP Demo Demonstration of Fast Unified Navigation, Manipulation And Planning (FUNMAP) Stretch URDF Calibration Tutorial Tutorial on URDF (re)calibration Stretch Description Guide Guide to working with the Stretch URDF and using 3rd party tools.","title":"ROS Interface"},{"location":"#release-notes","text":"Batch Errata","title":"Release Notes"},{"location":"#license","text":"This documentation is only to be used for an authentic Stretch RE1 robot produced and sold by Hello Robot Inc. All Hello Robot stretch_docs related materials are released under the Creative Commons Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0) license. . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"License"},{"location":"batch_errata/","text":"Batch Errata The Stretch RE1 is manufactured fixed size batches. There may be minor changes, issues, and improvements between batches. These errata are captured here. Each batch is named alphabetically after a musician. 'Guthrie' is the first publicly available version of Stretch. Guthrie Released May 2020 Known issues The sound localization of Guthrie can be inconsistent due to the acoustic properties of the enclosure around the ReSpeaker microphone array. The voice recognition accuracy is not affected. Workaround: remove the head shell for experiments requiring accurate localization. Contact support@hello-robot.com for instructions. A version incompatibility between the ROS D435i packages and the Intel RealSense packages can cause Realsense Viewer to stop finding the camera on the bus. This happens after the first time the ROS package utilizes the camera. Prior to running ROS, the viewer will work as expected. The provided EasySMX XBox controller can be set into an incorrect interface mode (when holding down the illuminated center button for a few seconds.) The correct mode is with the upper half of ring LEDs illuminated top two LED quarter circle arcs). To change it back to the correct mode, hold the center button down for 5s and release. Repeat until top half of ring is illuminated. Changes from prior version N/A . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Batch errata"},{"location":"batch_errata/#batch-errata","text":"The Stretch RE1 is manufactured fixed size batches. There may be minor changes, issues, and improvements between batches. These errata are captured here. Each batch is named alphabetically after a musician. 'Guthrie' is the first publicly available version of Stretch.","title":"Batch Errata"},{"location":"batch_errata/#guthrie","text":"Released May 2020 Known issues The sound localization of Guthrie can be inconsistent due to the acoustic properties of the enclosure around the ReSpeaker microphone array. The voice recognition accuracy is not affected. Workaround: remove the head shell for experiments requiring accurate localization. Contact support@hello-robot.com for instructions. A version incompatibility between the ROS D435i packages and the Intel RealSense packages can cause Realsense Viewer to stop finding the camera on the bus. This happens after the first time the ROS package utilizes the camera. Prior to running ROS, the viewer will work as expected. The provided EasySMX XBox controller can be set into an incorrect interface mode (when holding down the illuminated center button for a few seconds.) The correct mode is with the upper half of ring LEDs illuminated top two LED quarter circle arcs). To change it back to the correct mode, hold the center button down for 5s and release. Repeat until top half of ring is illuminated. Changes from prior version N/A . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Guthrie"},{"location":"hardware_user_guide/","text":"Hardware User Guide This manual provides the engineering data relevant to the use of the Hello Robot Stretch RE1 hardware. Disclaimer The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section on Regulatory Compliance for further details. Functional Specification Hardware Architecture Base The base is a two wheel differential drive with a passive Mecanum wheel for a caster. It includes four cliff sensors to allow detection of stairs, thresholds, etc. Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The base has 6 M4 threaded inserts available for mounting user accessories such as a tray. The mounting pattern is shown below. Base IMU Coming soon. Trunk Development and charge ports are at the back of the base in the trunk. The trunk cover slides into place vertically and is non-latching. The trunk height has been designed to accommodate one or more USB based Intel Neural Compute Sticks. Two mounting holes are provided inside the trunk. These allow the user to strain relief tethered cables (eg, HDMI and keyboard) during development. It is recommended to strain relief such cables to prevent accidental damage during base motion. Item Notes A Vent Intake vent for computer fan B 6 Port USB Hub USB 3.0 , powered 5V/3A C Ethernet Connected to computer NIC D On/Off Robot power on / off. Switch is illuminated when on. E Charge Rated for upplied 12V/7A charger F HDMI Connected to computer HDMI G Mounting points M4 threaded holes Head The head provides the audio interface to the robot, a pan tilt depth camera, a runstop, as well as a developer interface to allow the addition of additional user hardware. Item Notes A Pan tilt depth camera Intel RealSense D435i Two Dynamixel XL430-W250-T servos B Speakers C Mounting holes 2x M4 threaded, spacing 25mm D Developer Interface USB2.0-A with 5V@500mA fused JST XHP-2, 12V@3A fused Pin 1: 12V Pin 2: GND E Microphone array With programmable 12 RGB LED ring F Runstop G Audio volume control Pan Tilt The head pan-tilt unit utilizes two Dynamixel XL430-W250-T servos. It incorporates a small fan in order to ensure proper cooling of the servo and camera during dynamic repeated motions of the tilt DOF. The nominal \u2018zero\u2019 position is of the head is shown below, along with the corresponding range of motion. DOF Range (deg) Min(deg) Max (deg) Pan 225 -100 125 Tilt 115 -25 90 Runstop The runstop allows the user to pause the motion of the four primary DOF (base, lift, and arm) by tapping the illuminated button on the head. When the runstop is enabled, these DOF are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. Lift The lift degree of freedom provides vertical translation of the arm. It is driven by a closed loop stepper motor, providing smooth and precise motion through a low gear-ratio belt drive. The \u2018shoulder\u2019 includes two mounting holes and a small delivery tray. Item Notes A Delivery tray B Mounting holes Threaded M4. Spacing 34.5 mm. C Aruco Tag Size 40x40 mm Arm Coming soon. Wrist Wrist Accelerometer Coming soon. Expansion USB The wrist includes a USB 2.0 A interface. This port is fused to 500mA@5V. Expansion DIO The wrist includes an expansion DIO header that provides access to pins of the wrist Arduino board. The DIO connector can be accessed by removing the cap at the end of the arm. The header is wired to a Atmel SAMD21G18A-AUT ( datasheet ) microcontroller (same as Arduino Zero). The expansion header pins are configured at the factory to allow: General purpose digital I/O Analog input In addition, the firmware can be configured for other pin functions, including: Serial SPI Serial I2C Serial UART The Stretch Firmware Manual covers this modification. The DIO header pins utilize 3V3 TTL logic. They do not have interface protection (eg, ESD, over-voltage, shorts). It is possible to damage your robot if pin specifications are exceeded The pin mapping is: Pin Name Function Factory Firmware 1 DGND Digital ground 2 3V3 3.3V supply fused at 250mA. 3 E12V 12VDC fused at 500mA 4 SS DIO | SPI SS Digital out (D3) 5 SCK DIO | SPI SCK Digital out (D2) 6 MISO DIO | SPI MISO |UART TX Digital in (D0) 7 MOSI DIO | SPI MOSI Digital in (D1) 8 SCL DIO | I2C SCL Not used 9 SS DIO | I2C SDA Not used 10 ANA0 Analog input | UART RX Analog in (A0) The expansion DIO uses a 10 pin JST header B10B-PHDSS(LF)(SN) . It is compatible with a JST PHDR-10VS housing. JST provides pre-crimped wire compatible with this housing ( part APAPA22K305 ). Pin 1 & 10 are indicated below. The expansion DIO schematic shown below. Gripper Coming soon. Regulatory Compliance The Stretch Research Edition 1 (Stretch RE1) is not certified for use as a consumer device in the U.S. Unless stated otherwise, the Stretch RE1 is not subjected to compliance testing nor certified to meet any requirements, such as requirements for EMI, EMC, or ESD. Per FCC 47 CFR, Part 15, Subpart B, section 15.103(c) , we claim the Stretch Research Edition 1 as an exempted device, since it is a digital device used exclusively as industrial, commercial, or medical test equipment, where test equipment is equipment intended primarily for purposes of performing scientific investigations. OET BULLETIN NO. 62 , titled \"UNDERSTANDING THE FCC REGULATIONS FOR COMPUTERS AND OTHER DIGITAL DEVICES\" from December 1993 provides further clarification of the Section 15.103(c) exemption: \u201c Test equipment includes devices used for maintenance, research, evaluation, simulation and other analytical or scientific applications in areas such as industrial plants, public utilities, hospitals, universities, laboratories, automotive service centers and electronic repair shops.\u201d . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Hardware User Guide"},{"location":"hardware_user_guide/#hardware-user-guide","text":"This manual provides the engineering data relevant to the use of the Hello Robot Stretch RE1 hardware.","title":"Hardware User Guide"},{"location":"hardware_user_guide/#disclaimer","text":"The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section on Regulatory Compliance for further details.","title":"Disclaimer"},{"location":"hardware_user_guide/#functional-specification","text":"","title":"Functional Specification"},{"location":"hardware_user_guide/#hardware-architecture","text":"","title":"Hardware Architecture"},{"location":"hardware_user_guide/#base","text":"The base is a two wheel differential drive with a passive Mecanum wheel for a caster. It includes four cliff sensors to allow detection of stairs, thresholds, etc. Item Notes A Drive wheels 4 inch diameter, urethane rubber shore 60A B Cliff sensors Sharp GP2Y0A51SK0F, Analog, range 2-15 cm C Mecanum wheel Diameter 50mm The base has 6 M4 threaded inserts available for mounting user accessories such as a tray. The mounting pattern is shown below.","title":"Base"},{"location":"hardware_user_guide/#base-imu","text":"Coming soon.","title":"Base IMU"},{"location":"hardware_user_guide/#trunk","text":"Development and charge ports are at the back of the base in the trunk. The trunk cover slides into place vertically and is non-latching. The trunk height has been designed to accommodate one or more USB based Intel Neural Compute Sticks. Two mounting holes are provided inside the trunk. These allow the user to strain relief tethered cables (eg, HDMI and keyboard) during development. It is recommended to strain relief such cables to prevent accidental damage during base motion. Item Notes A Vent Intake vent for computer fan B 6 Port USB Hub USB 3.0 , powered 5V/3A C Ethernet Connected to computer NIC D On/Off Robot power on / off. Switch is illuminated when on. E Charge Rated for upplied 12V/7A charger F HDMI Connected to computer HDMI G Mounting points M4 threaded holes","title":"Trunk"},{"location":"hardware_user_guide/#head","text":"The head provides the audio interface to the robot, a pan tilt depth camera, a runstop, as well as a developer interface to allow the addition of additional user hardware. Item Notes A Pan tilt depth camera Intel RealSense D435i Two Dynamixel XL430-W250-T servos B Speakers C Mounting holes 2x M4 threaded, spacing 25mm D Developer Interface USB2.0-A with 5V@500mA fused JST XHP-2, 12V@3A fused Pin 1: 12V Pin 2: GND E Microphone array With programmable 12 RGB LED ring F Runstop G Audio volume control","title":"Head"},{"location":"hardware_user_guide/#pan-tilt","text":"The head pan-tilt unit utilizes two Dynamixel XL430-W250-T servos. It incorporates a small fan in order to ensure proper cooling of the servo and camera during dynamic repeated motions of the tilt DOF. The nominal \u2018zero\u2019 position is of the head is shown below, along with the corresponding range of motion. DOF Range (deg) Min(deg) Max (deg) Pan 225 -100 125 Tilt 115 -25 90","title":"Pan Tilt"},{"location":"hardware_user_guide/#runstop","text":"The runstop allows the user to pause the motion of the four primary DOF (base, lift, and arm) by tapping the illuminated button on the head. When the runstop is enabled, these DOF are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume.","title":"Runstop"},{"location":"hardware_user_guide/#lift","text":"The lift degree of freedom provides vertical translation of the arm. It is driven by a closed loop stepper motor, providing smooth and precise motion through a low gear-ratio belt drive. The \u2018shoulder\u2019 includes two mounting holes and a small delivery tray. Item Notes A Delivery tray B Mounting holes Threaded M4. Spacing 34.5 mm. C Aruco Tag Size 40x40 mm","title":"Lift"},{"location":"hardware_user_guide/#arm","text":"Coming soon.","title":"Arm"},{"location":"hardware_user_guide/#wrist","text":"","title":"Wrist"},{"location":"hardware_user_guide/#wrist-accelerometer","text":"Coming soon.","title":"Wrist Accelerometer"},{"location":"hardware_user_guide/#expansion-usb","text":"The wrist includes a USB 2.0 A interface. This port is fused to 500mA@5V.","title":"Expansion USB"},{"location":"hardware_user_guide/#expansion-dio","text":"The wrist includes an expansion DIO header that provides access to pins of the wrist Arduino board. The DIO connector can be accessed by removing the cap at the end of the arm. The header is wired to a Atmel SAMD21G18A-AUT ( datasheet ) microcontroller (same as Arduino Zero). The expansion header pins are configured at the factory to allow: General purpose digital I/O Analog input In addition, the firmware can be configured for other pin functions, including: Serial SPI Serial I2C Serial UART The Stretch Firmware Manual covers this modification. The DIO header pins utilize 3V3 TTL logic. They do not have interface protection (eg, ESD, over-voltage, shorts). It is possible to damage your robot if pin specifications are exceeded The pin mapping is: Pin Name Function Factory Firmware 1 DGND Digital ground 2 3V3 3.3V supply fused at 250mA. 3 E12V 12VDC fused at 500mA 4 SS DIO | SPI SS Digital out (D3) 5 SCK DIO | SPI SCK Digital out (D2) 6 MISO DIO | SPI MISO |UART TX Digital in (D0) 7 MOSI DIO | SPI MOSI Digital in (D1) 8 SCL DIO | I2C SCL Not used 9 SS DIO | I2C SDA Not used 10 ANA0 Analog input | UART RX Analog in (A0) The expansion DIO uses a 10 pin JST header B10B-PHDSS(LF)(SN) . It is compatible with a JST PHDR-10VS housing. JST provides pre-crimped wire compatible with this housing ( part APAPA22K305 ). Pin 1 & 10 are indicated below. The expansion DIO schematic shown below.","title":"Expansion DIO"},{"location":"hardware_user_guide/#gripper","text":"Coming soon.","title":"Gripper"},{"location":"hardware_user_guide/#regulatory-compliance","text":"The Stretch Research Edition 1 (Stretch RE1) is not certified for use as a consumer device in the U.S. Unless stated otherwise, the Stretch RE1 is not subjected to compliance testing nor certified to meet any requirements, such as requirements for EMI, EMC, or ESD. Per FCC 47 CFR, Part 15, Subpart B, section 15.103(c) , we claim the Stretch Research Edition 1 as an exempted device, since it is a digital device used exclusively as industrial, commercial, or medical test equipment, where test equipment is equipment intended primarily for purposes of performing scientific investigations. OET BULLETIN NO. 62 , titled \"UNDERSTANDING THE FCC REGULATIONS FOR COMPUTERS AND OTHER DIGITAL DEVICES\" from December 1993 provides further clarification of the Section 15.103(c) exemption: \u201c Test equipment includes devices used for maintenance, research, evaluation, simulation and other analytical or scientific applications in areas such as industrial plants, public utilities, hospitals, universities, laboratories, automotive service centers and electronic repair shops.\u201d . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Regulatory Compliance"},{"location":"quick_start_guide/","text":"Stretch RE1: Quick Start Guide Congratulations on your Stretch RE1! This guide will get you started with your new robot. We'd welcome your feedback as you get to know your robot. Please let us know of any issues, questions, or points of confusion. Just email us at support@hello-robot.com. To start, we highly recommend you first go through the Robot Safety Guide and watch our Robot Safety Video (coming soon). Unboxing Please watch our unboxing video (Coming soon) Robot Tour A few items you'll want to know about before getting started. Power The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. We recommend keeping the charger plugged in whenever it isn't running untethered. Runstop The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume. Safe Handling Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually tilt and roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Backdriving the head and wrist. They will backdrive but they want to go at their own speed. The arm will slowly descend when the robot is powered off. If the arm is retracted it may rest the tool on the base. If desired to hold the arm up when un-powered, the provided 'clip-clamp' can be clipped onto the mast below the shoulder to support it. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense) Hello World Demo Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step... Get Plugged In Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Log in to the robot computer. The default user credentials came in the box with the robot. Before you can start coding you'll want to first kill off the XBox controller process which runs by default at boot: >> pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop' Start Coding Open up a Terminal. From the command line, first verify that that all of the hardware is present and happy >> stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot >> stretch_robot_home.py Once the robot has homed, let's write some quick test code: >>ipython Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.stow() robot.arm.move_to(0.25) robot.push_command() robot.arm.move_to(0.0) robot.push_command() robot.lift.move_to(0.4) robot.push_command() robot.pretty_print() robot.lift.pretty_print() robot.head.pose('tool') robot.head.pose('ahead') robot.end_of_arm.move_to('wrist_yaw',0) robot.end_of_arm.move_to('stretch_gripper',50) robot.end_of_arm.move_to('gripper',-50) robot.stow() robot.stop() URDF Visualization Finally, let's look at the factory calibrated URDF for your robot. From the console run: >> stretch_urdf_show.py --motion Change Credentials Finally, we recommend that you change the login credentials for the default user, hello-robot. >>$ sudo passwd That's it. Happy coding! . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide/#stretch-re1-quick-start-guide","text":"Congratulations on your Stretch RE1! This guide will get you started with your new robot. We'd welcome your feedback as you get to know your robot. Please let us know of any issues, questions, or points of confusion. Just email us at support@hello-robot.com. To start, we highly recommend you first go through the Robot Safety Guide and watch our Robot Safety Video (coming soon).","title":"Stretch RE1: Quick Start Guide"},{"location":"quick_start_guide/#unboxing","text":"Please watch our unboxing video (Coming soon)","title":"Unboxing"},{"location":"quick_start_guide/#robot-tour","text":"A few items you'll want to know about before getting started.","title":"Robot Tour"},{"location":"quick_start_guide/#power","text":"The entire robot powers up and down with the On/Off switch. When powering down, we recommend selecting 'Power Off' from the Ubuntu Desktop prior to hitting the Off switch The provided battery charger can be plugged and unplugged at any time during operation. We recommend keeping the charger plugged in whenever it isn't running untethered.","title":"Power"},{"location":"quick_start_guide/#runstop","text":"The illuminated button on the head is its Runstop. Just tap it, you'll hear a beep and it will start flashing. This will pause motion of the primary robot joints during operation. This can be useful if the robot makes an unsafe motion, or if you just want to free up the robot motors while you roll it around. To allow motion once again, hold the button down for two seconds. After the beep, motion can resume.","title":"Runstop"},{"location":"quick_start_guide/#safe-handling","text":"Like any robot, it is possible to break Stretch if you're not careful. Use common sense when applying forces to its joints, transporting it, etc. Things that won't hurt the robot : Manually push and pull the arm (when the motor isn't holding a position). Manually raise and lower the lift (when the motor isn't holding a position). Manually tilt and roll the base around (when the motors aren't holding a position). Pick up and carry Stretch (while holding it by the mast, two people for safety). Things to be mindful of : Backdriving the head and wrist. They will backdrive but they want to go at their own speed. The arm will slowly descend when the robot is powered off. If the arm is retracted it may rest the tool on the base. If desired to hold the arm up when un-powered, the provided 'clip-clamp' can be clipped onto the mast below the shoulder to support it. Things that can hurt the robot : Driving the wrist and gripper into the base. When the arm and wrist are stowed it is possible to collide the two. Getting the gripper stuck on something and then driving the arm, lift, or base. Laying the robot down with it weight on its camera. Trying to ride on the robot, getting it wet, etc. (eg, common sense)","title":"Safe Handling"},{"location":"quick_start_guide/#hello-world-demo","text":"Stretch comes ready to run out of the box. The Xbox Teleoperation demo will let you quickly test out the robot capabilities by teleoperating it with an Xbox Controller. To start the demo after unboxing: Remove the 'trunk' cover and power on the robot Wait for about 45 seconds. You will hear the Ubuntu startup sound, followed by two beeps (indicating the demo is running). Hit the Connect button on the controller. The upper two LEDs of the ring will illuminate. Hit the Home Robot button. Stretch will go through its homing calibration routine. You're ready to go! A few things to try: Hit the Stow Robot button. The robot will assume the stow pose. Practice driving the robot around. Pull the Fast Base trigger while driving. When stowed, it will make Stretch drive faster Manually stop the arm or lift from moving to make it stop upon contact. Try picking up your cellphone from the floor Try grasping cup from a counter top Try delivering an object to a person If you're done, hold down the Shutdown PC button for 2 seconds. This will cause the PC to turn off. You can then power down the robot. Or proceed to the next step...","title":"Hello World Demo"},{"location":"quick_start_guide/#get-plugged-in","text":"Let's get plugged in. Remove the 'trunk' cover and power on the robot if its not already on. Plug in a mouse, keyboard and HDMI monitor to the robot trunk Plug in the battery charger Log in to the robot computer. The default user credentials came in the box with the robot. Before you can start coding you'll want to first kill off the XBox controller process which runs by default at boot: >> pkill -f stretch_xbox* While you're at it, disable this autoboot feature. You can always turn it back on later. Search for 'Startup' from Ubuntu Activities. Uncheck the box for 'hello_robot_xbox_teleop'","title":"Get Plugged In"},{"location":"quick_start_guide/#start-coding","text":"Open up a Terminal. From the command line, first verify that that all of the hardware is present and happy >> stretch_robot_system_check.py You may see a few joints reported in red because they haven't yet been calibrated. If so, home the robot >> stretch_robot_home.py Once the robot has homed, let's write some quick test code: >>ipython Now let's move the robot around using the Robot API. Try typing in these interactive commands at the iPython prompt: Python 2.7.17 (default, Apr 15 2020, 17:20:14) ... import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.stow() robot.arm.move_to(0.25) robot.push_command() robot.arm.move_to(0.0) robot.push_command() robot.lift.move_to(0.4) robot.push_command() robot.pretty_print() robot.lift.pretty_print() robot.head.pose('tool') robot.head.pose('ahead') robot.end_of_arm.move_to('wrist_yaw',0) robot.end_of_arm.move_to('stretch_gripper',50) robot.end_of_arm.move_to('gripper',-50) robot.stow() robot.stop()","title":"Start Coding"},{"location":"quick_start_guide/#urdf-visualization","text":"Finally, let's look at the factory calibrated URDF for your robot. From the console run: >> stretch_urdf_show.py --motion","title":"URDF Visualization"},{"location":"quick_start_guide/#change-credentials","text":"Finally, we recommend that you change the login credentials for the default user, hello-robot. >>$ sudo passwd That's it. Happy coding! . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Change Credentials"},{"location":"robot_care_guide/","text":"Robot Care Guide This guide describes best practices to maintain a happy and healthy Stretch RE1. Battery Maintenance The robot has two deep-cycle sealed lead acid batteries which provide 12V/19AH of charge. The provided charger will keep the system at a near full-charge if it is left plugged during non-tethered use. While deep-cycle batteries are robust to deep discharge states, it is recommended to avoid doing so if possible. The provide charger is able to recover form such a state if it occurs however. We recommend leaving the charger plugged in whenever the robot base is stationary. Battery State The battery charger LEDs provide an approximate indicator of battery charge. However, this is not especially accurate. A charged battery will typically report a voltage of 12-12.8V and will maintain that voltage across load conditions. Meanwhile, a partially charged battery may report anywhere from 10-12.8V but its voltage will drop rapidly when loaded. The voltage and current draw can be checked by; >>$ stretch_robot_battery_check.py [Pass] Voltage with 12.9889035225 [Pass] Current with 2.46239192784 [Pass] CPU Temp with 56.0 Run Time The run time for a fully charged system is dependent on the load use case. The vast majority of battery power is consumed by the NUC computer. While the motors can momentarily draw surge currents, the robot is designed such that minimal power is expended to hold the body up against gravity (which keeps average motor current low). The robot will continue to operate at battery voltages as low as 9.5V. A fully charged robot running a very high CPU load will take over 2 hours to discharge to 10V. Low Voltage Alert When the battery voltage drops below a YAML specified threshold the robot will produce an intermittent double beep sound. This is a reminder to the user to plug in the charger. This threshold is set at 10.5V at the factory but may be overridden. Battery Fuse The batteries are fused with a 20mm 8A / slow blow fuse. Nominal load currents for the robot are 3-5A for most use cases. The fuse provides protection against an internal short. Should the fuse blow, the robot will fail to power up. Should the fuse need replacement contact support@hello-robot.com. Belt Tension A neoprene timing belt drives the arm up and down the lift. It may detension over long periods of time if it experiences sustained loading. In this case, slack will become visually appearant in the belt as the lift moves. The belt is very straightforward to re-tension. Please contact support@hello-robot.com for tensioing instructions. Keeping the Robot Clean The robot surfaces can be wiped down with an alcohol wipe or a moist rag from time to time in order to remove and debris or oils that accumulate on the shells or mast. The drive wheels can accumulate dust over time and begin to lose traction. They should be periodically wiped down as well. When possible, the Trunk cover for the base should be kept on in order to keep dust and debris out of the Trunk connectors. Keeping the Robot Calibrated The robot comes pre-calibrated with a robot-specific URDF. This calibration allows the D435i depth sensor to accurately estimate where the robot wrist, and body, is in the depth image. The robot may become slightly uncalibrated over time for a variety of reasons: Normal wear and tear and loosening of joints of the robot The head structure is accidentally load and the structure becomes very slightly bent The wrist and should structure become accidentally highly loaded and become slightly bent The calibration accuracy can be checked using the provided ROS tools. If necessary, the user can recalibrate the robot. See the Stretch ROS User Guide for more information. Transporting the Robot Stretch was designed to be easily transported in the back of a car, up a stair case, or around a building. For short trips, the robot can be simply rolled around by grabbing its mast. It may be picked up by its mast and carried up stairs as well. For longer trips it is recommended to transport the robot in its original cardboard box with foam packaging. The metal protective cage that surrounds the head is only necessary if the robot might be shipped and the box will not remain upright. System Check It is useful to periodically run stretch_robot_system_check.py. This will check that the robot's hardware devices are present and within normal operating conditions. >>$ stretch_robot_system_check.py ---- Checking Devices ---- [Pass] : hello-wacc [Pass] : hello-motor-left-wheel [Pass] : hello-motor-arm [Pass] : hello-dynamixel-wrist [Pass] : hello-motor-right-wheel [Pass] : hello-motor-lift [Pass] : hello-pimu [Pass] : hello-respeaker [Pass] : hello-lrf [Pass] : hello-dynamixel-head ---- Checking Pimu ---- [Pass] Voltage = 12.8763639927 [Pass] Current = 3.25908634593 [Pass] Temperature = 36.3404559783 [Pass] Cliff-0 = -4.72064208984 [Pass] Cliff-1 = -8.56213378906 [Pass] Cliff-2 = 1.08505249023 [Pass] Cliff-3 = 5.68453979492 [Pass] IMU AZ = -9.80407142639 ---- Checking EndOfArm ---- [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: wrist_yaw [Pass] Calibrated: wrist_yaw [Dynamixel ID:014] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: stretch_gripper [Pass] Calibrated: stretch_gripper ---- Checking Head ---- [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_tilt [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_pan ---- Checking Wacc ---- [Pass] AX = 9.4840593338 ---- Checking hello-motor-left-wheel ---- [Pass] Position = 43.9992256165 ---- Checking hello-motor-right-wheel ---- [Pass] Position = 15.1164712906 ---- Checking hello-motor-arm ---- [Pass] Position = 59.7719421387 [Pass] Position Calibrated = True ---- Checking hello-motor-lift ---- [Pass] Position = 83.7744064331 [Pass] Position Calibrated = True ---- Checking for Intel D435i ---- Bus 002 Device 016: ID 8086:0b3a Intel Corp. [Pass] : Device found . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Robot Care Guide"},{"location":"robot_care_guide/#robot-care-guide","text":"This guide describes best practices to maintain a happy and healthy Stretch RE1.","title":"Robot Care Guide"},{"location":"robot_care_guide/#battery-maintenance","text":"The robot has two deep-cycle sealed lead acid batteries which provide 12V/19AH of charge. The provided charger will keep the system at a near full-charge if it is left plugged during non-tethered use. While deep-cycle batteries are robust to deep discharge states, it is recommended to avoid doing so if possible. The provide charger is able to recover form such a state if it occurs however. We recommend leaving the charger plugged in whenever the robot base is stationary.","title":"Battery Maintenance"},{"location":"robot_care_guide/#battery-state","text":"The battery charger LEDs provide an approximate indicator of battery charge. However, this is not especially accurate. A charged battery will typically report a voltage of 12-12.8V and will maintain that voltage across load conditions. Meanwhile, a partially charged battery may report anywhere from 10-12.8V but its voltage will drop rapidly when loaded. The voltage and current draw can be checked by; >>$ stretch_robot_battery_check.py [Pass] Voltage with 12.9889035225 [Pass] Current with 2.46239192784 [Pass] CPU Temp with 56.0","title":"Battery State"},{"location":"robot_care_guide/#run-time","text":"The run time for a fully charged system is dependent on the load use case. The vast majority of battery power is consumed by the NUC computer. While the motors can momentarily draw surge currents, the robot is designed such that minimal power is expended to hold the body up against gravity (which keeps average motor current low). The robot will continue to operate at battery voltages as low as 9.5V. A fully charged robot running a very high CPU load will take over 2 hours to discharge to 10V.","title":"Run Time"},{"location":"robot_care_guide/#low-voltage-alert","text":"When the battery voltage drops below a YAML specified threshold the robot will produce an intermittent double beep sound. This is a reminder to the user to plug in the charger. This threshold is set at 10.5V at the factory but may be overridden.","title":"Low Voltage Alert"},{"location":"robot_care_guide/#battery-fuse","text":"The batteries are fused with a 20mm 8A / slow blow fuse. Nominal load currents for the robot are 3-5A for most use cases. The fuse provides protection against an internal short. Should the fuse blow, the robot will fail to power up. Should the fuse need replacement contact support@hello-robot.com.","title":"Battery Fuse"},{"location":"robot_care_guide/#belt-tension","text":"A neoprene timing belt drives the arm up and down the lift. It may detension over long periods of time if it experiences sustained loading. In this case, slack will become visually appearant in the belt as the lift moves. The belt is very straightforward to re-tension. Please contact support@hello-robot.com for tensioing instructions.","title":"Belt Tension"},{"location":"robot_care_guide/#keeping-the-robot-clean","text":"The robot surfaces can be wiped down with an alcohol wipe or a moist rag from time to time in order to remove and debris or oils that accumulate on the shells or mast. The drive wheels can accumulate dust over time and begin to lose traction. They should be periodically wiped down as well. When possible, the Trunk cover for the base should be kept on in order to keep dust and debris out of the Trunk connectors.","title":"Keeping the Robot Clean"},{"location":"robot_care_guide/#keeping-the-robot-calibrated","text":"The robot comes pre-calibrated with a robot-specific URDF. This calibration allows the D435i depth sensor to accurately estimate where the robot wrist, and body, is in the depth image. The robot may become slightly uncalibrated over time for a variety of reasons: Normal wear and tear and loosening of joints of the robot The head structure is accidentally load and the structure becomes very slightly bent The wrist and should structure become accidentally highly loaded and become slightly bent The calibration accuracy can be checked using the provided ROS tools. If necessary, the user can recalibrate the robot. See the Stretch ROS User Guide for more information.","title":"Keeping the Robot Calibrated"},{"location":"robot_care_guide/#transporting-the-robot","text":"Stretch was designed to be easily transported in the back of a car, up a stair case, or around a building. For short trips, the robot can be simply rolled around by grabbing its mast. It may be picked up by its mast and carried up stairs as well. For longer trips it is recommended to transport the robot in its original cardboard box with foam packaging. The metal protective cage that surrounds the head is only necessary if the robot might be shipped and the box will not remain upright.","title":"Transporting the Robot"},{"location":"robot_care_guide/#system-check","text":"It is useful to periodically run stretch_robot_system_check.py. This will check that the robot's hardware devices are present and within normal operating conditions. >>$ stretch_robot_system_check.py ---- Checking Devices ---- [Pass] : hello-wacc [Pass] : hello-motor-left-wheel [Pass] : hello-motor-arm [Pass] : hello-dynamixel-wrist [Pass] : hello-motor-right-wheel [Pass] : hello-motor-lift [Pass] : hello-pimu [Pass] : hello-respeaker [Pass] : hello-lrf [Pass] : hello-dynamixel-head ---- Checking Pimu ---- [Pass] Voltage = 12.8763639927 [Pass] Current = 3.25908634593 [Pass] Temperature = 36.3404559783 [Pass] Cliff-0 = -4.72064208984 [Pass] Cliff-1 = -8.56213378906 [Pass] Cliff-2 = 1.08505249023 [Pass] Cliff-3 = 5.68453979492 [Pass] IMU AZ = -9.80407142639 ---- Checking EndOfArm ---- [Dynamixel ID:013] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: wrist_yaw [Pass] Calibrated: wrist_yaw [Dynamixel ID:014] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: stretch_gripper [Pass] Calibrated: stretch_gripper ---- Checking Head ---- [Dynamixel ID:012] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_tilt [Dynamixel ID:011] ping Succeeded. Dynamixel model number : 1060 [Pass] Ping of: head_pan ---- Checking Wacc ---- [Pass] AX = 9.4840593338 ---- Checking hello-motor-left-wheel ---- [Pass] Position = 43.9992256165 ---- Checking hello-motor-right-wheel ---- [Pass] Position = 15.1164712906 ---- Checking hello-motor-arm ---- [Pass] Position = 59.7719421387 [Pass] Position Calibrated = True ---- Checking hello-motor-lift ---- [Pass] Position = 83.7744064331 [Pass] Position Calibrated = True ---- Checking for Intel D435i ---- Bus 002 Device 016: ID 8086:0b3a Intel Corp. [Pass] : Device found . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"System Check"},{"location":"robot_safety_guide/","text":"Robot Safety Guide Before You Start This manual is intended to help users become familiar with safe operating practices and use of the Hello Robot Stretch RE1 All users should read and become familiar with the safe operating procedures before operating the robot. Disclaimer The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section Regulatory Compliance for further details. Safety It is important for users to keep safety in mind at all times while operating a Hello Robot. When improperly used it is possible for users, bystanders, and property to become harmed. All new users of Hello Robot products should be trained by experienced personnel on best practices for safe operation and interaction with the robot. Because Stretch is a mobile manipulator with autonomous capabilities, it may move in unpredictable ways. It may carry potentially dangerous objects that can contact people in unexpected ways. While it is relatively lightweight and able to only exert moderate forces on the environment, dangerous conditions can still occur. The moving components of the robot pose dangers of pinching and crushing of body parts. People should always be aware and attentive to the motion and of Stretch robots. The intended use of the Stretch RE1 is for research and development of mobile manipulation applications within laboratory settings. No robot is ever inherently safe and common sense safety measures should be applied when using Stretch, Safety Features We have considered safety from the outset in the design of Stretch. Lightweight design: The overall mass of Stretch is 22Kg, and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : The arrangement of Stretch\u2019s manipulator means that it doesn\u2019t have to counteract gravity on a larger lever arm. As a result, the motors and gearboxes are much lower torque and lower weight than a traditional robot manipulator, allowing us to avoid the often dangerous strong shoulder joints of robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low, gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and, arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Velocity limits : Fast motions of the base are restricted when the arm is up high and tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. An over-tilt condition will trigger a runstop event, causing motion to stop. Use Common Sense The most important aspect of safety with Stretch is to use common sense, including Do not operate unattended by an experienced operator Exhibit caution when operating around young children who may interact with it in unexpected ways Keep an eye on cords, rugs, and any other floor hazards as it drives Keep it at least 5 meters from ledges, curbs, stairs, and any other toppling hazard Keep long hair and clothes away from the moving components of the robot. Do not operate out doors Keep the robot dry and do not operate around liquids Do not attempt to ride the robot If the robot appears to be damaged, stop operation immediately Do not have the robot hold any sharp objects. Use two people to lift and carry the robot when needed Safety Markings Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast: Top of base, indicating potential pinch point between arm and base. Runstop The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid The default behavior of the Safety Mode for each actuator is: Actuator Safety Mode Behavior Notes Left wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Right wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Lift Float Motor drive is powered on and commanding current to motor that compensates for gravity (eg, float). Lift can be backdriven by the user. Arm Float Motor drive is powered off. Arm can be backdriven manually by user. Safety Hazards Like all robots, Stretch has some areas that require extra attention for safe operation. Sharp Edges Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp corners edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted. Toppling Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and it hits a bump, threshold, or other change in floor property If the arm is raised up high and it pushes or pulls on the environment with sufficient force. It drives over a drop-off such as a stair or curb NOTE: While the Stretch RE1 has cliff sensors, they do not currently inhibit motion of the base. As such, it is possible for the robot to fall down stairs and hurt itself or a person. Pinch Points Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. C Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers. Crush Points The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. Nominally, this threshold is around 70N but it can be configured in software. When enabled an operating as expected, the Guarded Move controller should keep contact forces within comfortable and safe levels. The diagrams below show the potential crush points at the top and bottom of the lift range of motion. . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Robot Safety Guide"},{"location":"robot_safety_guide/#robot-safety-guide","text":"","title":"Robot Safety Guide"},{"location":"robot_safety_guide/#before-you-start","text":"This manual is intended to help users become familiar with safe operating practices and use of the Hello Robot Stretch RE1 All users should read and become familiar with the safe operating procedures before operating the robot.","title":"Before You Start"},{"location":"robot_safety_guide/#disclaimer","text":"The Hello Robot Stretch Robot is intended for use in the research of mobile manipulation applications by users experienced in the use and programming of research robots. This product is not intended for general use in the home by consumers, and lacks the required certifications for such use. Please see the section Regulatory Compliance for further details.","title":"Disclaimer"},{"location":"robot_safety_guide/#safety","text":"It is important for users to keep safety in mind at all times while operating a Hello Robot. When improperly used it is possible for users, bystanders, and property to become harmed. All new users of Hello Robot products should be trained by experienced personnel on best practices for safe operation and interaction with the robot. Because Stretch is a mobile manipulator with autonomous capabilities, it may move in unpredictable ways. It may carry potentially dangerous objects that can contact people in unexpected ways. While it is relatively lightweight and able to only exert moderate forces on the environment, dangerous conditions can still occur. The moving components of the robot pose dangers of pinching and crushing of body parts. People should always be aware and attentive to the motion and of Stretch robots. The intended use of the Stretch RE1 is for research and development of mobile manipulation applications within laboratory settings. No robot is ever inherently safe and common sense safety measures should be applied when using Stretch,","title":"Safety"},{"location":"robot_safety_guide/#safety-features","text":"We have considered safety from the outset in the design of Stretch. Lightweight design: The overall mass of Stretch is 22Kg, and the majority of the mass is in the base. The carbon fiber arm and aluminum mast make for a remarkably lightweight upper body. While this reduces the risk of crushing, crushing injury can still occur and should be carefully monitored. Gravity friendly : The arrangement of Stretch\u2019s manipulator means that it doesn\u2019t have to counteract gravity on a larger lever arm. As a result, the motors and gearboxes are much lower torque and lower weight than a traditional robot manipulator, allowing us to avoid the often dangerous strong shoulder joints of robot arms. Low gear ratio : The primary joints of Stretch (base, lift, and arm) have low, gear-ratios (approx 5:1), allowing for backdriving of joints when powered off. A low gear-ratio also reduces the effective inertia of each joint, limiting the impacted force during undesired contacts with people and the environment. Contact Sensitivity : The four primary joints of Stretch (base, lift, and, arm) have contact sensitivity. We measure motor currents to estimate contact forces. Because Stretch is a low gear-ratio robot, current sensing provides a fairly sensitive measure of contact forces. Firmware limits : Motor torques are limited at the lowest level of the firmware to configured bounds. Runstop : The illuminated runstop button on Stretch\u2019s head can be used to pause operation of the four primary joints (base, lift, and arm) of the robot when it is in motion. Velocity limits : Fast motions of the base are restricted when the arm is up high and tool is outside the base footprint. This limits the likelihood of toppling or snagging the tool during base motion. Tilt detection : The robot can detect when its body is tilted beyond a safe threshold. An over-tilt condition will trigger a runstop event, causing motion to stop.","title":"Safety Features"},{"location":"robot_safety_guide/#use-common-sense","text":"The most important aspect of safety with Stretch is to use common sense, including Do not operate unattended by an experienced operator Exhibit caution when operating around young children who may interact with it in unexpected ways Keep an eye on cords, rugs, and any other floor hazards as it drives Keep it at least 5 meters from ledges, curbs, stairs, and any other toppling hazard Keep long hair and clothes away from the moving components of the robot. Do not operate out doors Keep the robot dry and do not operate around liquids Do not attempt to ride the robot If the robot appears to be damaged, stop operation immediately Do not have the robot hold any sharp objects. Use two people to lift and carry the robot when needed","title":"Use Common Sense"},{"location":"robot_safety_guide/#safety-markings","text":"Stretch has the following safety markings: Top of shoulder, indicating potential pinch point between rollers and mast: Top of base, indicating potential pinch point between arm and base.","title":"Safety Markings"},{"location":"robot_safety_guide/#runstop","text":"The runstop allows the user to pause the motion of the four primary actuators (base, lift, and arm) by tapping the illuminated button on the head. An experienced operator should always keep the runstop within reach, allowing them to stop the motion of the robot if it is deemed unsafe. NOTE: The runstop is not equivalent to an Emergency Stop found on industrial equipment and no safety guarantees are made by its function . When the runstop is enabled, these actuators are in a \u2018Safety Mode\u2019 that inhibits the motion controller at the firmware level. Disabling the runstop allows normal operation to resume. The runstop logic is: Action Runstop State Button Illumination Robot startup Motion enabled Solid Tap runstop button Motion disabled Flashing at 1Hz Hold down runstop button for >2s Motion enabled Solid The default behavior of the Safety Mode for each actuator is: Actuator Safety Mode Behavior Notes Left wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Right wheel Freewheel Motor drive is powered off. Base can be backdriven manually by user. Lift Float Motor drive is powered on and commanding current to motor that compensates for gravity (eg, float). Lift can be backdriven by the user. Arm Float Motor drive is powered off. Arm can be backdriven manually by user.","title":"Runstop"},{"location":"robot_safety_guide/#safety-hazards","text":"Like all robots, Stretch has some areas that require extra attention for safe operation.","title":"Safety Hazards"},{"location":"robot_safety_guide/#sharp-edges","text":"Stretch RE1 is a piece of laboratory equipment. As such, its structure has moderately sharp corners edges and corners that can be unsafe. These edges can get snagged during motion, or they may cause lacerations when sufficient force is applied to a person. Care should be taken when grasping or otherwise making contact with Stretch that a sharp corner or edge is not contacted.","title":"Sharp Edges"},{"location":"robot_safety_guide/#toppling","text":"Stretch is a relatively lightweight robot. In some kinematic configurations a high center of gravity can make it prone to toppling. Toppling can occur when: The mobile base is moving at moderate or fast speed and it hits a bump, threshold, or other change in floor property If the arm is raised up high and it pushes or pulls on the environment with sufficient force. It drives over a drop-off such as a stair or curb NOTE: While the Stretch RE1 has cliff sensors, they do not currently inhibit motion of the base. As such, it is possible for the robot to fall down stairs and hurt itself or a person.","title":"Toppling"},{"location":"robot_safety_guide/#pinch-points","text":"Pinch points around the robot's head, gripper, and wrist can cause discomfort and care should be taken when handling these joints as they move. The shoulder, which travels up and down on the lift, has a series of rollers that ride along the mast. While the shoulder shells can prevent large objects from getting pinched by the rollers, small and thin objects can be pulled into and crushed. C Extra care should be taken with long hair, clothing, and small fingers around the shoulder rollers.","title":"Pinch Points"},{"location":"robot_safety_guide/#crush-points","text":"The lift degree of freedom is the strongest joint on the robot and as such can apply potentially unsafe forces to a person. The lift, while in motion, may trap or crush objects between the \u2018shoulder\u2019 and another surface. As such, best practices for lift safety should always be used when using the lift degree of freedom. The lift has a max theoretical strength of nearly 200N of linear force. In practice, this force is limited by the lift\u2019s Guarded Move function, which places the lift in Safety Mode when the actuator forces exceed a threshold. Nominally, this threshold is around 70N but it can be configured in software. When enabled an operating as expected, the Guarded Move controller should keep contact forces within comfortable and safe levels. The diagrams below show the potential crush points at the top and bottom of the lift range of motion. . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Crush Points"},{"location":"stretch_body_guide/","text":"Stretch Body Package The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The package is available on Git and installable via Pip . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators. Robot Interface The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() for i in range(10): robot.pretty_print() time.sleep(0.25) robot.stop() Looking at this in detail: import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. robot=stretch_body.robot.Robot() robot.startup() Here we instantiate an instance of our Robot. The call to startup( ) opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. for i in range(10): robot.pretty_print() time.sleep(0.25) The call to pretty_print( ) prints to console all of the robot's sensor and state data. robot.stop() Finally, the stop( ) method shuts down the Robot threads and cleanly closes the open serial ports. Units The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians The Robot Status The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm(Device): def __init__(self): ... self.status = {'pos': 0.0, 'vel': 0.0, 'force':0.0, \\ 'motor':self.motor.status,'timestamp_pc':0} The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot.arm.status['pos']>0.25: print 'Arm extension greater than 0.25m' If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status=robot.get_status() if status['arm']['pos']>0.25: print 'Arm extension greater than 0.25m' The Robot Command In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.arm.move_by(-0.1) robot.push_command() time.sleep(2.0) robot.stop() A few important things are going on: robot.arm.move_by(0.1) The move_by( ) method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. robot.push_command() The push_command( ) causes all queued up RPC commands to be executed at once. In this example we call sleep( ) to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot.arm.move_by(0.1) robot.lift.move_by(0.1) robot.base.translate_by(0.1) robot.push_command() Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section. Stowing and Homing After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot.is_calibrated(): robot.home() #blocking Or it can be done manually after boot using the command line tool: >>$ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot.stow() #blocking Or it can be done manually from the command line when needed: >>$ stretch_robot_stow.py Scripting the Robot A simplified design pattern to script the Robot is as follows #!/usr/bin/env python import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot=stretch_body.robot.Robot() robot.startup() x_move_base =0 x_move_arm =0 x_move_lift =0 x_move_head_pan =0 x_move_head_tilt =0 x_move_wrist_yaw =0 x_move_gripper =0 def update_my_behavior(status): #Update the joint commands based on the status data pass try: while True: #Get a snapshot of the robot status data status=robot.get_status() #Compute new position targets based on sensor data update_my_behavior(status) #Queue new targets to devices robot.base.translate_by(x_move_base) #or robot.base.rotate_by() robot.arm.move_by(x_move_arm) robot.lift.move_by(x_move_lift) robot.head.move_by('head_pan',x_move_head_pan) robot.head.move_by('head_tilt',x_move_head_tilt) robot.end_of_arm.move_by('wrist_yaw',x_move_wrist_yaw) robot.end_of_arm.move_by('gripper',x_move_gripper) #Synchronized send of new position targets robot.push_command() #Wait for next control cycle time.sleep(0.1) except (KeyboardInterrupt, SystemExit,ThreadServiceExit) pass robot.stop() Command Line Tools The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. >>$ stretch_ stretch_arm_home.py stretch_head_jog.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_lift_home.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wrist_yaw_jog.py stretch_base_jog.py stretch_lift_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_xbox_controller_teleop.py stretch_gripper_home.py stretch_pimu_jog.py stretch_robot_jog.py stretch_wacc_jog.py stretch_gripper_jog.py stretch_pimu_scope.py stretch_robot_keyboard_teleop.py stretch_wacc_scope.py stretch_urdf_show.py stretch_rp_lidar_jog.py stretch_hardware_echo.py stretch_audio_test.py All tools accept '--help' as a command line argument to learn its function. For example: >>$ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap Commonly Used Tools These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem. Robot Motion Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.stop() Motion Profiles All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm: motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} To move the arm quickly instead: vel_fast_m = robot.arm.params['motion']['fast']['vel_m'] accel_fast_m = robot.arm.params['motion']['fast']['accel_m'] robot.arm.move_by(x_m=0.1,v_m=vel_fast_m, a_m=accel_fast_m) robot.push_command() The motion will fall back to the 'default' settings found in the YAML if no parameters are provided. Range of Motion All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift: range_m: [0.1, 1.095] Control Modes Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the device.startup( ) function is called it transitions to its Control Mode. It is placed back in Safety Mode when device.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot.base.translate_by(x_m=0.5) robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.1) #switch to velocity controller robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.0) #stop motion robot.push_command() As shown, care should be taken to reduce commanded velocities to zero to avoid runaway. Runstop Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot.pimu.status['runstop_event']: robot.pimu.runstop_event_reset() robot.push_command() Guarded Motion The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm: contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot.arm.move_by(x_m=0.1, contact_thresh_pos_N=30.0) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot.arm.motor.status['in_guarded_event']: print 'Arm has made contact' The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot.arm.move_to(0.5) #Reach all the way out robot.push_command() while robot.arm.status['pos']<0.5: if robot.arm.motor.status['in_guarded_event']: print 'Contact made at', robot.arm.status['pos'] break time.sleep(0.1) print 'Retracting...' robot.arm.move_to(0.0) robot.push_command( ) Note: The units of Newtons are approximations only and may not be accurate to real world contact forces. Synchronized Motion The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm: gains: {enable_sync_mode: 1,...} Motion Status It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot.arm.status['pos'] #Joint position robot.arm.status['vel'] #Joint velocity robot.arm.status['force'] #Joint force (derived from motor current) robot.arm.motor.status['near_pos_setpoint'] #Is sensed position near commanded position robot.arm.motor.status['near_vel_setpoint'] #Is sensed velocity near commanded velocity robot.arm.motor.status['is_moving'] #Is the joint in motion robot.arm.motor.status['in_guarded_event'] #Has a guarded event occured robot.arm.motor.status['in_safety_event'] #Has a safety event occured Update Rates The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics. Robot Parameters All robot data is stored in the stretch_user directory. The location of this directory can be found by: >>$ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) cd $HELLO_FLEET_PATH/$HELLO_FLEET_ID >>$ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros export_urdf udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users. Calibration Data The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development. URDF Data A calibrated URDF, and associated mesh files, are provided in the 'export_urdf' directory. This is provided for users who don't wish to use ROS yet still want an accurate model of the robot. The stretch_urdf_view.py tool demonstrates how to visualize the URDF from Python. YAML Data Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools. Factory Parameters This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base. User Parameters The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params: stretch_re1_factory_params.yaml tool_params: stretch_re1_tool_params.yaml lift: contact_thresh_N: [-60, 60] motion: default: {accel_m: 0.15, vel_m: 0.095} arm: contact_thresh_N: [-80, 80] motion: default: {accel_m: 0.14, vel_m: 0.14} base: motion: default: {accel_m: 0.1, vel_m: 0.15} End of Arm Tool Parameters The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information coming soon. Safe Operation Functions Stretch includes a number of built-in functions that help it maintain safe operating conditions. These functions can be disabled and enabled via the robot YAML parameters. Logging Upon instantiation, the Robot class opens a new log file for warning and informational messages to be written to. These timestamped logs are found under $HELLO_FLEET_DIRECTORY/log. The logging messages can be echoed to the console by setting: robot: log_to_console: 1 Runstop Functions YAML Function stop_at_low_voltage Trigger runstop / beep when voltage too low stop_at_high_current Trigger runstop when bus current too high stop_at_cliff Trigger runstop when a cliff sensor is outside of range stop_at_runstop Allow runstop to disable motors stop_at_tilt Trigger runstop when robot tilts too far Robot Monitor The Robot Monitor is a thread that monitors the Robot Status data for significant events. For example, it can monitor the error flags from the Dynamixel servos and notify when a thermal overload occurs. The Robot Monitor logs warnings to a log file by default. YAML Function monitor_base_bump_event Report when the accelerometer detects a bump event monitor_base_cliff_event Report when a cliff sensor event occurs monitor_current Report when the battery current exceeds desired range monitor_dynamixel_flags Report when a Dynamixel servo enters an error state monitor_guarded_contact Report when a guarded contact event occurs monitor_over_tilt_alert Report when an over-tilt event occurs monitor_runstop Report when the runstop is activated / deactivated monitor_voltage Report when the battery voltage is out of range monitor_wrist_single_tap Report when the wrist accelerometer reports a single tap event The YAML below illustrates the types of events that are can be configured. robot: log_to_console: 0 use_monitor: 1 use_sentry: 1 robot_monitor: monitor_base_bump_event: 1 monitor_base_cliff_event: 1 monitor_current: 1 monitor_dynamixel_flags: 1 monitor_guarded_contact: 1 monitor_over_tilt_alert: 1 monitor_runstop: 1 monitor_voltage: 1 monitor_wrist_single_tap: 1 robot_sentry: base_fan_control: 1 base_max_velocity: 1 stretch_gripper_overload: 1 wrist_yaw_overload: 1 Robot Sentry The Robot Sentry is a thread that can override and also generate commands to the robot hardware. It's purpose is to keep the robot operating within a safe regime. For example, the Robot Sentry monitors the position of the Lift and Arm and limits the maximum base velocity and acceleration (in order to reduce the chance of toppling). The Robot Sentry reports events to the log file as well. YAML Function base_fan_control Turn the fan on when CPU temp exceeds range base_max_velocity Limit the base velocity when robot CG is high stretch_gripper_overload Reset commanded position to prevent thermal overload during grasp wrist_yaw_overload Reset commanded position to prevent thermal overload during pushing . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch Body Package"},{"location":"stretch_body_guide/#stretch-body-package","text":"The Stretch_Body package provides a low level Python API to the Stretch RE1 hardware. The package is available on Git and installable via Pip . It encapsulates Mobile base Arm Lift Head actuators Wrist and tool actuators Wrist accelerometer and Arduino Base power and IMU board The robot's 3rd party hardware devices are intended to be accessed through ROS and not Stretch_Body. However, it is possible to directly access this hardware through open-source Python packages: Laser range finder: rplidar Respeaker: respeaker_python_library D435i: pyrealsense2 The Stretch_Body package is intended for advanced users who prefer to not use ROS to control the robot. It assumes a moderate level of experience programming robot sensors and actuators.","title":"Stretch Body Package"},{"location":"stretch_body_guide/#robot-interface","text":"The primary developer interface to Stretch_Body is the Robot class . As an example, the Python script below prints all Robot sensor and state data to the console every 250ms. import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() for i in range(10): robot.pretty_print() time.sleep(0.25) robot.stop() Looking at this in detail: import stretch_body.robot The package stretch_body includes the Python module for Robot as well as other Devices such as Lift and Arm. robot=stretch_body.robot.Robot() robot.startup() Here we instantiate an instance of our Robot. The call to startup( ) opens the serial ports to the various devices, loads the Robot YAML parameters, and launches a few helper threads. for i in range(10): robot.pretty_print() time.sleep(0.25) The call to pretty_print( ) prints to console all of the robot's sensor and state data. robot.stop() Finally, the stop( ) method shuts down the Robot threads and cleanly closes the open serial ports.","title":"Robot Interface"},{"location":"stretch_body_guide/#units","text":"The Robot API uses SI units of: meters radians seconds Newtons Amps Volts Parameters may be named with a suffix to help describe the unit type. For example: pos_m : meters pos_r: radians","title":"Units"},{"location":"stretch_body_guide/#the-robot-status","text":"The Robot derives from the Device class . It also encapsulates a number of other Devices: robot.head robot.arm robot.lift robot.base robot.wacc robot.pimu robot.end_of_arm All devices contain a Status dictionary. The Status contains the most recent sensor and state data of that device. For example, looking at the Arm class we see: class Arm(Device): def __init__(self): ... self.status = {'pos': 0.0, 'vel': 0.0, 'force':0.0, \\ 'motor':self.motor.status,'timestamp_pc':0} The Status dictionaries are automatically updated by a background thread of the Robot at 25Hz. The Status data can be accessed via the Robot. For example: if robot.arm.status['pos']>0.25: print 'Arm extension greater than 0.25m' If an instantaneous snapshot of the entire Robot Status is needed, the get_status() method can be used instead: status=robot.get_status() if status['arm']['pos']>0.25: print 'Arm extension greater than 0.25m'","title":"The Robot Status"},{"location":"stretch_body_guide/#the-robot-command","text":"In contrast to the Robot Status which pulls data from the Devices, the Robot Command pushes data to the Devices. Consider the following example which extends and then retracts the arm by 0.1 meters: import time import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.arm.move_by(-0.1) robot.push_command() time.sleep(2.0) robot.stop() A few important things are going on: robot.arm.move_by(0.1) The move_by( ) method queues up an RPC command to the stepper motor controller. However, the command does not yet execute. robot.push_command() The push_command( ) causes all queued up RPC commands to be executed at once. In this example we call sleep( ) to allow time for the motion to complete before initiating a new motion. NOTE : The Dynamixel servos do not use the Hello Robot RPC protocol. As such, the head, wrist, and gripper will move immediately upon issuing a motion command. The stepper actuators support a synchronous mode, allowing the base, arm, and lift to synchronously track trajectories. Thus, the following code will cause the base, arm, and lift to initiate motion simultaneously: robot.arm.move_by(0.1) robot.lift.move_by(0.1) robot.base.translate_by(0.1) robot.push_command() Commanding robot motion through the Stretch_Body interface is covered in more detail in the Robot Motion section.","title":"The Robot Command"},{"location":"stretch_body_guide/#stowing-and-homing","text":"After power up the robot requires homing in order for its joint encoders to find their zero position. The homing procedure will run the robot through a series of moves to find these zeros. It can be done programatically: if not robot.is_calibrated(): robot.home() #blocking Or it can be done manually after boot using the command line tool: >>$ stretch_robot_home.py Likewise, stowing is a robot procedure that will cause it to move its arm and tool safely within the footprint of the base. robot.stow() #blocking Or it can be done manually from the command line when needed: >>$ stretch_robot_stow.py","title":"Stowing and Homing"},{"location":"stretch_body_guide/#scripting-the-robot","text":"A simplified design pattern to script the Robot is as follows #!/usr/bin/env python import stretch_body.robot from stretch_body.hello_utils import ThreadServiceExit robot=stretch_body.robot.Robot() robot.startup() x_move_base =0 x_move_arm =0 x_move_lift =0 x_move_head_pan =0 x_move_head_tilt =0 x_move_wrist_yaw =0 x_move_gripper =0 def update_my_behavior(status): #Update the joint commands based on the status data pass try: while True: #Get a snapshot of the robot status data status=robot.get_status() #Compute new position targets based on sensor data update_my_behavior(status) #Queue new targets to devices robot.base.translate_by(x_move_base) #or robot.base.rotate_by() robot.arm.move_by(x_move_arm) robot.lift.move_by(x_move_lift) robot.head.move_by('head_pan',x_move_head_pan) robot.head.move_by('head_tilt',x_move_head_tilt) robot.end_of_arm.move_by('wrist_yaw',x_move_wrist_yaw) robot.end_of_arm.move_by('gripper',x_move_gripper) #Synchronized send of new position targets robot.push_command() #Wait for next control cycle time.sleep(0.1) except (KeyboardInterrupt, SystemExit,ThreadServiceExit) pass robot.stop()","title":"Scripting the Robot"},{"location":"stretch_body_guide/#command-line-tools","text":"The Stretch_Body package comes with a suite of command line tools that allow direct interaction with hardware subsystems. These can be useful when developing and debugging applications. They also serve as code examples when developing applications for Stretch_Body. These tools can be found by tab completion of 'stretch_' from a terminal. >>$ stretch_ stretch_arm_home.py stretch_head_jog.py stretch_robot_battery_check.py stretch_robot_monitor.py stretch_wrist_yaw_home.py stretch_arm_jog.py stretch_lift_home.py stretch_robot_dynamixel_reboot.py stretch_robot_stow.py stretch_wrist_yaw_jog.py stretch_base_jog.py stretch_lift_jog.py stretch_robot_home.py stretch_robot_system_check.py stretch_xbox_controller_teleop.py stretch_gripper_home.py stretch_pimu_jog.py stretch_robot_jog.py stretch_wacc_jog.py stretch_gripper_jog.py stretch_pimu_scope.py stretch_robot_keyboard_teleop.py stretch_wacc_scope.py stretch_urdf_show.py stretch_rp_lidar_jog.py stretch_hardware_echo.py stretch_audio_test.py All tools accept '--help' as a command line argument to learn its function. For example: >>$ stretch_wacc_scope.py --help usage: stretch_wacc_scope.py [-h] [--ax] [--ay] [--az] [--a0] [--d0] [--d1] [--tap] Visualize Wacc (Wrist+Accel) board data with an oscilloscope optional arguments: -h, --help show this help message and exit --ax Scope accelerometer AX --ay Scope accelerometer AY --az Scope accelerometer AZ --a0 Scope analog-in-0 --d0 Scope digital-in-0 --d1 Scope digital-in-1 --tap Scope single tap","title":"Command Line Tools"},{"location":"stretch_body_guide/#commonly-used-tools","text":"These are the tools a typical user will want to become familiar with. Tool Utility stretch_robot_home.py Commonly run after booting up the robot in-order to calibrate the joints stretch_robot_system_check.py Scans for all hardware devices and ensure they are present on the bus and reporting valid values. Useful to verify that the robot is in good working order prior to commanding motion. It will report all success in green, failures in red. stretch_robot_stow.py Useful to return the robot arm and tool to a safe position within the base footprint. It can also be useful if a program fails to exit cleanly and the robot joints are not backdriveable. It will restore them to their 'Safety' state. stretch_robot_battery_check.py Quick way to check the battery voltage / current consumption stretch_xbox_controller_teleop.py Useful to quickly test if a robot can achieve a task by manually teleoperating the robot stretch_robot_dynamixel_reboot.py This will reset all Dynamixels in the robot, which may be needed if a servo overheats during high use and enters an error state. The other tools are fairly self explanatory. They allow the user to quickly read a sensor value or control an individual hardware subsystem.","title":"Commonly Used Tools"},{"location":"stretch_body_guide/#robot-motion","text":"Controlling the motion of the robot's actuators is typically done through the ROS interfaces. However it is also possible to control the robot directly through the stretch_body interfaces. Actuators are commanded by either a move_by or move_to command (the former being incremental, the latter being absolute). For example, a relative move using the default motion parameters of the arm looks like: import stretch_body.robot robot=stretch_body.robot.Robot() robot.startup() robot.arm.move_by(0.1) robot.push_command() time.sleep(2.0) robot.stop()","title":"Robot Motion"},{"location":"stretch_body_guide/#motion-profiles","text":"All joints support trapezoidal based motion generation. Other types of controllers are available (PID, velocity, etc) but they are not covered here . The trapezoidal motion controllers require three values: x: target position of joint v: maximum velocity of motion a: acceleration of motion We provide 'default' settings for the velocity and acceleration settings, as well as 'fast', and 'slow' settings. These values have been tuned to be appropriate for safe motion of the robot. These values can be seen in the 'stretch_re1_factory_params.yaml'. For example: arm: motion: fast: {accel_m: 0.2, vel_m: 0.2} default: {accel_m: 0.14, vel_m: 0.14} max: {accel_m: 1.0, vel_m: 1.0} slow: {accel_m: 0.07, vel_m: 0.06} To move the arm quickly instead: vel_fast_m = robot.arm.params['motion']['fast']['vel_m'] accel_fast_m = robot.arm.params['motion']['fast']['accel_m'] robot.arm.move_by(x_m=0.1,v_m=vel_fast_m, a_m=accel_fast_m) robot.push_command() The motion will fall back to the 'default' settings found in the YAML if no parameters are provided.","title":"Motion Profiles"},{"location":"stretch_body_guide/#range-of-motion","text":"All joints obey motion limits which are specified in the factory YAML. These limits have been set at the factory to prevent damage to the hardware. It is not recommended to set them to be greater than the factory specified values. However, they can be further limited if desired. For example. to prevent the lift from descending within 100mm of the base, one can override the factory setting in stretch_re1_user_params.yaml lift: range_m: [0.1, 1.095]","title":"Range of Motion"},{"location":"stretch_body_guide/#control-modes","text":"Each joint has a default safety mode and default control mode. These are: Joint Default Safety Mode Default Control Mode left_wheel Freewheel Trapezoidal position control right_wheel Freewheel Trapezoidal position control lift Gravity compensated 'float' Trapezoidal position control arm Freewheel Trapezoidal position control head_pan Torque disabled Trapezoidal position control head_tilt Torque disabled Trapezoidal position control wrist_yaw Torque disabled Trapezoidal position control stretch_gripper Torque disabled Trapezoidal position control The actuator remains in Safety Mode when no program is running. When the device.startup( ) function is called it transitions to its Control Mode. It is placed back in Safety Mode when device.stop() is called. In addition, the Base supports a velocity control mode. The Base controllers will automatically switch between velocity and position based control. For example: robot.base.translate_by(x_m=0.5) robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.1) #switch to velocity controller robot.push_command() time.sleep(4.0) #wait robot.base.set_rotational_velocity(v_r=0.0) #stop motion robot.push_command() As shown, care should be taken to reduce commanded velocities to zero to avoid runaway.","title":"Control Modes"},{"location":"stretch_body_guide/#runstop","text":"Runstop activation will cause the Base, Arm, and Lift to switch to Safety Mode and for motion commands will be ignored. The motion commands will resume smoothly when the runstop is deactivated. This is usually done via the runstop button. However, it can also be done via the Pimu interface: if robot.pimu.status['runstop_event']: robot.pimu.runstop_event_reset() robot.push_command()","title":"Runstop"},{"location":"stretch_body_guide/#guarded-motion","text":"The Arm, Lift, and Base support a guarded motion function. It will automatically transition the actuator from Control mode to Safety mode when the exerted motor torque exceeds a threshold. This functionality is most useful for the Lift and the Arm. It allows these joints to safely stop upon contact. It can be used to: Safely stop when contacting an actuator hardstop Safely stop when making unexpected contact with the environment or a person Make a guarded motion where the robot reaches to a surface and then stops Each of these tasks have different force characteristics and may require different threshold settings. The factory defaults are set so as to allow freespace motion without a payload (without triggering a false positive stop). These thresholds are set in the factory YAML. For example: arm: contact_thresh_N: [-50, 50] contact_thresh_max_N: [-80, 80] A user can dynamically set the contact thresholds depending on the task requirements. For example, to make the arm extension motion more sensitive: robot.arm.move_by(x_m=0.1, contact_thresh_pos_N=30.0) If too sensitive, the joint may trigger false positives (e.g., stop without contact), and different thresholds may be needed in different portions of the workspace. When a guarded motion event has occurred it is reported in the Status: if robot.arm.motor.status['in_guarded_event']: print 'Arm has made contact' The guarded event can be reset and motion resumed by simply sending a new motion command to the joint (that is not identical to the previous command). Here is a simple example of moving to contact, then moving back: robot.arm.move_to(0.5) #Reach all the way out robot.push_command() while robot.arm.status['pos']<0.5: if robot.arm.motor.status['in_guarded_event']: print 'Contact made at', robot.arm.status['pos'] break time.sleep(0.1) print 'Retracting...' robot.arm.move_to(0.0) robot.push_command( ) Note: The units of Newtons are approximations only and may not be accurate to real world contact forces.","title":"Guarded Motion"},{"location":"stretch_body_guide/#synchronized-motion","text":"The Arm, Lift, and Base actuators have a hardware synchronization mechanism. This allows for controller commands to be time synchronized across joints. By default these are turned out in the factory YAML: hello-motor-arm: gains: {enable_sync_mode: 1,...}","title":"Synchronized Motion"},{"location":"stretch_body_guide/#motion-status","text":"It can be useful to poll the status of a joint during motion in order to modify the robot behavior, etc. The useful status values include: robot.arm.status['pos'] #Joint position robot.arm.status['vel'] #Joint velocity robot.arm.status['force'] #Joint force (derived from motor current) robot.arm.motor.status['near_pos_setpoint'] #Is sensed position near commanded position robot.arm.motor.status['near_vel_setpoint'] #Is sensed velocity near commanded velocity robot.arm.motor.status['is_moving'] #Is the joint in motion robot.arm.motor.status['in_guarded_event'] #Has a guarded event occured robot.arm.motor.status['in_safety_event'] #Has a safety event occured","title":"Motion Status"},{"location":"stretch_body_guide/#update-rates","text":"The following update rates apply to Stretch: Item Rate Notes Status data for Arm, Lift, Base, Wacc, and Pimu 25Hz Polled automatically by Robot thread Status data for End of Arm and Head servos 15Hz Polled automatically by Robot thread Command data for Arm, Lift, Base, Wacc, Pimu N/A Commands are queued and executed upon calling robot.push_command( ) Command data for End of Arm and Head servos N/A Commands execute immediately Motion commands are non-blocking and it is the responsibility of the user code to poll the Robot Status to determine when and if a motion target has been achieved. The Stretch_Body interface is not designed to support high bandwidth control applications. The natural dynamics of the robot actuators do not support high bandwidth contorl, and the USB based interface limits high rate communication. In practice, a Python based control loop that calls push_command( ) at 1Hz to 10Hz is sufficiently matched to the robot natural dynamics.","title":"Update Rates"},{"location":"stretch_body_guide/#robot-parameters","text":"All robot data is stored in the stretch_user directory. The location of this directory can be found by: >>$ echo $HELLO_FLEET_PATH /home/hello-robot/stretch_user The robot data stored here is identified by the robot ID (eg, stretch-re1-1002) cd $HELLO_FLEET_PATH/$HELLO_FLEET_ID >>$ ls calibration_base_imu calibration_guarded_contact calibration_steppers calibration_D435i calibration_ros export_urdf udev stretch_re1_factory_params.yaml stretch_re1_user_params.yaml stretch_re1_tool_params.yaml A factory image of this data (as shipped), is stored read-only under /etc/hello-robot . This is only for backup and to support cloning the user environment for new users.","title":"Robot Parameters"},{"location":"stretch_body_guide/#calibration-data","text":"The raw calibration data that was used in production for the robot is also stored for reference within the stretch_user directory. It isn't generally required for development.","title":"Calibration Data"},{"location":"stretch_body_guide/#urdf-data","text":"A calibrated URDF, and associated mesh files, are provided in the 'export_urdf' directory. This is provided for users who don't wish to use ROS yet still want an accurate model of the robot. The stretch_urdf_view.py tool demonstrates how to visualize the URDF from Python.","title":"URDF Data"},{"location":"stretch_body_guide/#yaml-data","text":"Stretch_Body relies upon the following three primary YAML files: File Purpose stretch_re1_factory_params.yaml Factory settings for controller gains, calibrations, and system configuration. Read only stretch_re1_user_params.yaml User parameters that override the factory parameters stretch_re1_tool_params.yaml Settings and configuration data for optional 3rd party end-of-arm tools.","title":"YAML Data"},{"location":"stretch_body_guide/#factory-parameters","text":"This stretch_re1_factory_params.yaml file contains the robot's 'factory' settings. This includes things such as PID parameters for motor controllers, calibration constants, and default joint velocities and accelerations. The user should not edit this file. Hello Robot retains an 'as shipped' version of this file should it ever get corrupted. It can be instructive to review this file when getting to know the Stretch_Body code base.","title":"Factory Parameters"},{"location":"stretch_body_guide/#user-parameters","text":"The factory settings should suffice for most use cases. However, the user is allowed to override the factory settings. This is done by using same YAML structure and name as is used in the stretch_re1_user_params.yaml file as in the factory file. For example, heres the stretch_re1_user_params.yaml file is overriding the factory default contact thresholds and motion speeds. factory_params: stretch_re1_factory_params.yaml tool_params: stretch_re1_tool_params.yaml lift: contact_thresh_N: [-60, 60] motion: default: {accel_m: 0.15, vel_m: 0.095} arm: contact_thresh_N: [-80, 80] motion: default: {accel_m: 0.14, vel_m: 0.14} base: motion: default: {accel_m: 0.1, vel_m: 0.15}","title":"User Parameters"},{"location":"stretch_body_guide/#end-of-arm-tool-parameters","text":"The stretch_re1_tool_params.yaml file stores configuration parameters specific to the user's custom end-of-arm-tools. It is read by the Robot class and the parameter data is made accessible to the user's end-of-arm-tool class. More information coming soon.","title":"End of Arm Tool Parameters"},{"location":"stretch_body_guide/#safe-operation-functions","text":"Stretch includes a number of built-in functions that help it maintain safe operating conditions. These functions can be disabled and enabled via the robot YAML parameters.","title":"Safe Operation Functions"},{"location":"stretch_body_guide/#logging","text":"Upon instantiation, the Robot class opens a new log file for warning and informational messages to be written to. These timestamped logs are found under $HELLO_FLEET_DIRECTORY/log. The logging messages can be echoed to the console by setting: robot: log_to_console: 1","title":"Logging"},{"location":"stretch_body_guide/#runstop-functions","text":"YAML Function stop_at_low_voltage Trigger runstop / beep when voltage too low stop_at_high_current Trigger runstop when bus current too high stop_at_cliff Trigger runstop when a cliff sensor is outside of range stop_at_runstop Allow runstop to disable motors stop_at_tilt Trigger runstop when robot tilts too far","title":"Runstop Functions"},{"location":"stretch_body_guide/#robot-monitor","text":"The Robot Monitor is a thread that monitors the Robot Status data for significant events. For example, it can monitor the error flags from the Dynamixel servos and notify when a thermal overload occurs. The Robot Monitor logs warnings to a log file by default. YAML Function monitor_base_bump_event Report when the accelerometer detects a bump event monitor_base_cliff_event Report when a cliff sensor event occurs monitor_current Report when the battery current exceeds desired range monitor_dynamixel_flags Report when a Dynamixel servo enters an error state monitor_guarded_contact Report when a guarded contact event occurs monitor_over_tilt_alert Report when an over-tilt event occurs monitor_runstop Report when the runstop is activated / deactivated monitor_voltage Report when the battery voltage is out of range monitor_wrist_single_tap Report when the wrist accelerometer reports a single tap event The YAML below illustrates the types of events that are can be configured. robot: log_to_console: 0 use_monitor: 1 use_sentry: 1 robot_monitor: monitor_base_bump_event: 1 monitor_base_cliff_event: 1 monitor_current: 1 monitor_dynamixel_flags: 1 monitor_guarded_contact: 1 monitor_over_tilt_alert: 1 monitor_runstop: 1 monitor_voltage: 1 monitor_wrist_single_tap: 1 robot_sentry: base_fan_control: 1 base_max_velocity: 1 stretch_gripper_overload: 1 wrist_yaw_overload: 1","title":"Robot Monitor"},{"location":"stretch_body_guide/#robot-sentry","text":"The Robot Sentry is a thread that can override and also generate commands to the robot hardware. It's purpose is to keep the robot operating within a safe regime. For example, the Robot Sentry monitors the position of the Lift and Arm and limits the maximum base velocity and acceleration (in order to reduce the chance of toppling). The Robot Sentry reports events to the log file as well. YAML Function base_fan_control Turn the fan on when CPU temp exceeds range base_max_velocity Limit the base velocity when robot CG is high stretch_gripper_overload Reset commanded position to prevent thermal overload during grasp wrist_yaw_overload Reset commanded position to prevent thermal overload during pushing . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Robot Sentry"},{"location":"stretch_ros_guide/","text":"Stretch ROS Guide Coming soon. . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch ROS Guide"},{"location":"stretch_ros_guide/#stretch-ros-guide","text":"Coming soon. . All materials are Copyright 2020 by Hello Robot Inc. The Stretch RE1 robot has patents pending","title":"Stretch ROS Guide"},{"location":"untethered_operation/","text":"Untethered Operation As a mobile manipulator, the Stretch RE1 can only go so far when tethered to the monitor, keyboard, and mouse setup. This guide will explain three methods of setting up the Stretch RE1 for untethered usage. Both methods typically requires a wireless network, but it is possible to setup either of these methods without a wireless network by setting up a hotspot . Remote Desktop Requirements This is the recommended approach if you are running Windows or MacOS. This method requires a Virtual Network Computing (VNC) package. Using any of the free or paid options available for Windows, MacOS, and Chrome will be fine since they all use the Remote Frame Buffer (RFB) protocol to communicate with the robot. If you're using Ubuntu, Remmina Remote Desktop Client will be installed by default. How To While the Stretch RE1 is tethered to the monitor, keyboard, and mouse setup, go to System Setting first verify that the robot is connected to the wireless network. Then, select the Sharing tab and turn it on. Then, turn on Screen Sharing and choose a password. If you plan to connect to the robot from a Windows or MacOS machine, then open a terminal and run the following command. sudo gsettings set org.gnome.Vino require-encryption false Finally, we need the robot's IP address, username, and password. Open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. The robot's default username and password is printed on papers that came in the tools box alongside the robot. Next, on your computer, connect to the same wireless network as the robot and open the VNC package being used. Using the robot's IP address and username, initialize a new connection to the robot. The robot's desktop will open in a new window. SSH & X Server Requirements This is the recommended approach if you are running an Unix-based operating system, like Ubuntu or Arch Linux. This method requires both SSH and X Server to be installed. While most Unix-based operating systems have both installed by default, MacOS will only have SSH installed and Windows has neither installed by default. It is possible to install these tools for MacOS or Windows. How To While the Remote Desktop approach requires only a VNC, the approach is often slow. In this method, we will use SSH and X Server to accomplish the same a bit faster. SSH stands for Secure Shell, enabling one to remotely use the terminal (shell) of another machine. X Server is used on many Unix variants to render the Windowed GUI of applications and it makes possible to render on your machine's screen the Windowed GUI of an application running on another machine. The first step is to identify the robot's IP address on the local network. While the Stretch RE1 is tethered to the monitor, keyboard, and mouse, verify that the robot is connected to a wireless network. Then, open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. Using any other machine on the same local network, I can SSH into the robot using this IP address. Take note of the username and password of the robot. The default combo is printed on papers that came in the tools box alongside the robot. To SSH into the robot, run the following. It will require the password and may ask you to add the robot to the known hosts. ssh -X username@ip-address Now that you're SSH-ed into the robot, you can disconnect any wires from the robot. You can accomplish any of the same tasks through the terminal. For example, you can type in ipython and try out all of the same python commands from stretch_body that were explained in the Getting Started Guide . Furthermore, Windowed GUI applications that would have displayed on the monitor will now display on your SSH-ed machine. For example, we can open Rviz to visualize what the robot is seeing. Open two terminals and SSH into the robot as explained above. In the first, run roslaunch stretch_core stretch_driver.launch . You should see the robot's Lidar begin to spin and some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use ROS tools can be found in ROS's tutorials or in our guides on using stretch_ros . Moving files to/from the robot wirelessly It's common to need to move files to/from the robot wirelessly and a tool similar to SSH can help with this: Secure Copy (SCP). This tool will not copy directories, so you may need to zip your files up prior to copying them over. To send the files from your computer to the robot, run: scp ./filename username@ip-address:~/path/to/put/it/ The copy files from the robot to your computer, run the reverse: scp username@ip-address:/path/to/filename ~/path/to/put/it/ ROS Remote Master Requirements This is the recommended approach if you are running Ubuntu 16.04/18.04 with ROS kinetic/melodic installed. This method will utilize the local installation of ROS tools, such as Rviz, rostopic, and rosservice, while retreiving data from the robot. How To If you are developing ROS code to test on the Stretch RE1 and you already have ROS installed on your local Ubuntu machine, then there is an easier way of using Rviz than the method described in SSH & X Server . In the ROS world, this concept is known as \"remote master\". First, start the ROS launch files on the robot as you normally would. On you local machine, run: export ROS_MASTER_URI=http://username@ip-address:11311 Then you may use tools like Rviz, rostopic, or rosservice on your local machine as you would have on the robot. Additional information can be found in the ROS Multiple Machines Tutorial . Additional Ideas Although the methods described above will enable you to wirelessly control the robot, there are a number of way to improve usability and security of your wireless connection. These ideas are listed here. Hotspot Often the trouble with wirelessly controlling the robot is the network. If your network is using industrial security like 2-factor authentication, there may be trouble connecting the robot to the network. If the network is servicing a large number of users, the connection may feel sluggish. The alternative is to skip the network by connecting directly to the robot through a hotspot. Connected through the hotspot, you can follow instructions for either method described above to control the robot. The trade-off is that while connected to the robot's hotspot, you will be unable to connect to the internet. To setup the robot's hotspot, visit the Wifi Settings page in the robot. Click on the hamburger menu in the top right and select \"Enable hotspot\". From your local machine, connect to the robot's hotspot and save the credentials. To change the hotspot's password or enable the hotspot automatically whenever the robot boots, see the following Stackoverflow post . VS Code Remote Development It is possible to simultaneously develop code on the robot while running wireless experiments using the Remote Development Extension provided by the VS Code IDE. If you're already using the VS Code IDE , navigate to the Extensions tab and search for Remote Development Extension by Microsoft . After installing, click on a green button in the bottom left of the screen and then select \"Remote-SSH: Connect to Host\". Setting this up for the first time will require you to know the robot's IP address and username. Add a new host with the information. While connecting, VS Code will ask you for the password of the robot. Once you are connected, you can open any folder and edit the code remotely. Combined with the method explained in SSH & X Server , this is a powerful method of iteratively developing code while testing it. Static IP Address Routers that serve wireless networks often dynamically assign IP address to machines that connect to the network. This means that your robot's IP address may have changed since the last time you turned it on. Since it becomes a pain to connect to the monitor, keyboard, and mouse setup every time to run ifconfig , many users prefer to assign the robot a static IP address. If you control the router, visit the router's setting page to setup the robot's static IP address. It is common at universities and companies to have staff dedicated to the management of the network. This staff will often be able to setup a static IP address for the robot. Public Key Authentication The method of SSH described in SSH & X Server is the most basic method of SSH-ing. There is better and more-secure method of SSH-ing into the robot called Public Key Authentication. This method will allow multiple developers to SSH into the robot without having to share the robot's admin password. The first step is to generating a public and private keys on your computer. Linux and MacOS machines can simply open the terminal and run: ssh-keygen It will prompt you to enter a password. If you do, you'll need it to use the private key when you SSH into the robot. Next, we give the robot the public key. Linux and MacOS machines can run: ssh-copy-id username@ip-address This requires you to know the username and ip-address of the robot. Instructions on how to find this information is found in the SSH & X Server section. You may now SSH into the robot as normal.","title":"Untethered Operation"},{"location":"untethered_operation/#untethered-operation","text":"As a mobile manipulator, the Stretch RE1 can only go so far when tethered to the monitor, keyboard, and mouse setup. This guide will explain three methods of setting up the Stretch RE1 for untethered usage. Both methods typically requires a wireless network, but it is possible to setup either of these methods without a wireless network by setting up a hotspot .","title":"Untethered Operation"},{"location":"untethered_operation/#remote-desktop","text":"","title":"Remote Desktop"},{"location":"untethered_operation/#requirements","text":"This is the recommended approach if you are running Windows or MacOS. This method requires a Virtual Network Computing (VNC) package. Using any of the free or paid options available for Windows, MacOS, and Chrome will be fine since they all use the Remote Frame Buffer (RFB) protocol to communicate with the robot. If you're using Ubuntu, Remmina Remote Desktop Client will be installed by default.","title":"Requirements"},{"location":"untethered_operation/#how-to","text":"While the Stretch RE1 is tethered to the monitor, keyboard, and mouse setup, go to System Setting first verify that the robot is connected to the wireless network. Then, select the Sharing tab and turn it on. Then, turn on Screen Sharing and choose a password. If you plan to connect to the robot from a Windows or MacOS machine, then open a terminal and run the following command. sudo gsettings set org.gnome.Vino require-encryption false Finally, we need the robot's IP address, username, and password. Open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. The robot's default username and password is printed on papers that came in the tools box alongside the robot. Next, on your computer, connect to the same wireless network as the robot and open the VNC package being used. Using the robot's IP address and username, initialize a new connection to the robot. The robot's desktop will open in a new window.","title":"How To"},{"location":"untethered_operation/#ssh-x-server","text":"","title":"SSH &amp; X Server"},{"location":"untethered_operation/#requirements_1","text":"This is the recommended approach if you are running an Unix-based operating system, like Ubuntu or Arch Linux. This method requires both SSH and X Server to be installed. While most Unix-based operating systems have both installed by default, MacOS will only have SSH installed and Windows has neither installed by default. It is possible to install these tools for MacOS or Windows.","title":"Requirements"},{"location":"untethered_operation/#how-to_1","text":"While the Remote Desktop approach requires only a VNC, the approach is often slow. In this method, we will use SSH and X Server to accomplish the same a bit faster. SSH stands for Secure Shell, enabling one to remotely use the terminal (shell) of another machine. X Server is used on many Unix variants to render the Windowed GUI of applications and it makes possible to render on your machine's screen the Windowed GUI of an application running on another machine. The first step is to identify the robot's IP address on the local network. While the Stretch RE1 is tethered to the monitor, keyboard, and mouse, verify that the robot is connected to a wireless network. Then, open a terminal and run ifconfig , which will print out the network information of the machine. In the wireless section (typically named wlp2s0), look for something that looks like \"inet 10.0.0.15\". The four numbers represent the IP address of the robot on the local network. Using any other machine on the same local network, I can SSH into the robot using this IP address. Take note of the username and password of the robot. The default combo is printed on papers that came in the tools box alongside the robot. To SSH into the robot, run the following. It will require the password and may ask you to add the robot to the known hosts. ssh -X username@ip-address Now that you're SSH-ed into the robot, you can disconnect any wires from the robot. You can accomplish any of the same tasks through the terminal. For example, you can type in ipython and try out all of the same python commands from stretch_body that were explained in the Getting Started Guide . Furthermore, Windowed GUI applications that would have displayed on the monitor will now display on your SSH-ed machine. For example, we can open Rviz to visualize what the robot is seeing. Open two terminals and SSH into the robot as explained above. In the first, run roslaunch stretch_core stretch_driver.launch . You should see the robot's Lidar begin to spin and some information print out in the terminal. In the second, run rviz . A window will pop up and information about the robot can be visualized by clicking on Add -> RobotModel and Add -> By Topic -> /Scan . Additional information on how to use ROS tools can be found in ROS's tutorials or in our guides on using stretch_ros .","title":"How To"},{"location":"untethered_operation/#moving-files-tofrom-the-robot-wirelessly","text":"It's common to need to move files to/from the robot wirelessly and a tool similar to SSH can help with this: Secure Copy (SCP). This tool will not copy directories, so you may need to zip your files up prior to copying them over. To send the files from your computer to the robot, run: scp ./filename username@ip-address:~/path/to/put/it/ The copy files from the robot to your computer, run the reverse: scp username@ip-address:/path/to/filename ~/path/to/put/it/","title":"Moving files to/from the robot wirelessly"},{"location":"untethered_operation/#ros-remote-master","text":"","title":"ROS Remote Master"},{"location":"untethered_operation/#requirements_2","text":"This is the recommended approach if you are running Ubuntu 16.04/18.04 with ROS kinetic/melodic installed. This method will utilize the local installation of ROS tools, such as Rviz, rostopic, and rosservice, while retreiving data from the robot.","title":"Requirements"},{"location":"untethered_operation/#how-to_2","text":"If you are developing ROS code to test on the Stretch RE1 and you already have ROS installed on your local Ubuntu machine, then there is an easier way of using Rviz than the method described in SSH & X Server . In the ROS world, this concept is known as \"remote master\". First, start the ROS launch files on the robot as you normally would. On you local machine, run: export ROS_MASTER_URI=http://username@ip-address:11311 Then you may use tools like Rviz, rostopic, or rosservice on your local machine as you would have on the robot. Additional information can be found in the ROS Multiple Machines Tutorial .","title":"How To"},{"location":"untethered_operation/#additional-ideas","text":"Although the methods described above will enable you to wirelessly control the robot, there are a number of way to improve usability and security of your wireless connection. These ideas are listed here.","title":"Additional Ideas"},{"location":"untethered_operation/#hotspot","text":"Often the trouble with wirelessly controlling the robot is the network. If your network is using industrial security like 2-factor authentication, there may be trouble connecting the robot to the network. If the network is servicing a large number of users, the connection may feel sluggish. The alternative is to skip the network by connecting directly to the robot through a hotspot. Connected through the hotspot, you can follow instructions for either method described above to control the robot. The trade-off is that while connected to the robot's hotspot, you will be unable to connect to the internet. To setup the robot's hotspot, visit the Wifi Settings page in the robot. Click on the hamburger menu in the top right and select \"Enable hotspot\". From your local machine, connect to the robot's hotspot and save the credentials. To change the hotspot's password or enable the hotspot automatically whenever the robot boots, see the following Stackoverflow post .","title":"Hotspot"},{"location":"untethered_operation/#vs-code-remote-development","text":"It is possible to simultaneously develop code on the robot while running wireless experiments using the Remote Development Extension provided by the VS Code IDE. If you're already using the VS Code IDE , navigate to the Extensions tab and search for Remote Development Extension by Microsoft . After installing, click on a green button in the bottom left of the screen and then select \"Remote-SSH: Connect to Host\". Setting this up for the first time will require you to know the robot's IP address and username. Add a new host with the information. While connecting, VS Code will ask you for the password of the robot. Once you are connected, you can open any folder and edit the code remotely. Combined with the method explained in SSH & X Server , this is a powerful method of iteratively developing code while testing it.","title":"VS Code Remote Development"},{"location":"untethered_operation/#static-ip-address","text":"Routers that serve wireless networks often dynamically assign IP address to machines that connect to the network. This means that your robot's IP address may have changed since the last time you turned it on. Since it becomes a pain to connect to the monitor, keyboard, and mouse setup every time to run ifconfig , many users prefer to assign the robot a static IP address. If you control the router, visit the router's setting page to setup the robot's static IP address. It is common at universities and companies to have staff dedicated to the management of the network. This staff will often be able to setup a static IP address for the robot.","title":"Static IP Address"},{"location":"untethered_operation/#public-key-authentication","text":"The method of SSH described in SSH & X Server is the most basic method of SSH-ing. There is better and more-secure method of SSH-ing into the robot called Public Key Authentication. This method will allow multiple developers to SSH into the robot without having to share the robot's admin password. The first step is to generating a public and private keys on your computer. Linux and MacOS machines can simply open the terminal and run: ssh-keygen It will prompt you to enter a password. If you do, you'll need it to use the private key when you SSH into the robot. Next, we give the robot the public key. Linux and MacOS machines can run: ssh-copy-id username@ip-address This requires you to know the username and ip-address of the robot. Instructions on how to find this information is found in the SSH & X Server section. You may now SSH into the robot as normal.","title":"Public Key Authentication"}]}